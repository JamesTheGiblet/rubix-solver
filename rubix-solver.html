<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rubik's Cube Solver</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{font-family:Segoe UI,Tahoma,Geneva,Verdana,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;overflow:hidden;touch-action:none}
#container{display:flex;flex-direction:column;height:100vh;padding:10px}
#canvas-container{flex:1;position:relative;overflow:hidden;border-radius:15px;background:rgba(0,0,0,.2);margin-bottom:10px;min-height:250px}
#controls{background:rgba(0,0,0,.3);padding:15px;border-radius:15px;backdrop-filter:blur(10px);max-height:55vh;overflow-y:auto}
.button-row{display:flex;gap:10px;margin-bottom:10px;flex-wrap:wrap}
button{flex:1;min-width:80px;padding:12px;border:none;border-radius:8px;font-size:14px;font-weight:bold;cursor:pointer;transition:.3s;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;box-shadow:0 4px 15px rgba(0,0,0,.2)}
button:active{transform:scale(.95)}
button:disabled{opacity:.5;cursor:not-allowed}
.rotation-buttons{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px}
.rotation-buttons button{font-size:16px;padding:15px 5px}
#status{text-align:center;padding:10px;background:rgba(0,0,0,.2);border-radius:8px;margin-bottom:10px;font-size:14px;min-height:40px;display:flex;align-items:center;justify-content:center}
.status-solving{background:rgba(255,193,7,.3)}
.status-solved{background:rgba(76,175,80,.3)}
h1{text-align:center;margin-bottom:10px;font-size:24px;text-shadow:2px 2px 4px rgba(0,0,0,.3)}
.legend{font-size:11px;text-align:center;opacity:.8;margin-top:8px}
#move-counter{text-align:center;margin-bottom:10px;font-size:16px;font-weight:bold;background:rgba(0,0,0,.2);padding:8px;border-radius:8px}
#move-history{background:rgba(0,0,0,.4);border-radius:8px;padding:10px;margin-bottom:10px;max-height:80px;overflow-y:auto;font-family:monospace;font-size:12px;line-height:1.4;word-break:break-all}
#speed-control{display:flex;align-items:center;gap:10px;margin-bottom:10px}
#speed-control label{font-size:12px;white-space:nowrap}
#speed-slider{flex:1}
#manual-input{width:100%;padding:10px;border:none;border-radius:8px;margin-bottom:10px;font-family:monospace;font-size:14px}
#solve-steps{background:rgba(0,0,0,.3);border-radius:8px;padding:10px;margin-bottom:10px;font-size:12px}
#solve-steps .step{padding:5px;margin:2px 0;border-radius:4px}
#solve-steps .step.active{background:rgba(255,193,7,.3);font-weight:bold}
#solve-steps .step.complete{background:rgba(76,175,80,.2)}
#color-palette{display:flex;gap:8px;margin-bottom:10px;justify-content:center;flex-wrap:wrap}
#execute-btn{width:100%;margin-bottom:10px}
.color-btn{width:40px;height:40px;border:3px solid #fff;border-radius:8px;cursor:pointer;transition:.3s;position:relative}
.color-btn:hover{transform:scale(1.1);box-shadow:0 4px 15px rgba(255,255,255,.4)}
.color-btn.active{border-color:#ffff00;box-shadow:0 0 15px rgba(255,255,0,.8)}
.color-btn::after{content:'';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:30px;height:30px;border-radius:4px}
.color-white::after{background:#ffffff}
.color-yellow::after{background:#ffff00}
.color-green::after{background:#00dd00}
.color-blue::after{background:#0000ff}
.color-orange::after{background:#ff8800}
.color-red::after{background:#ff0000}
#paint-mode{text-align:center;margin-bottom:10px;font-size:14px;background:rgba(0,0,0,.2);padding:8px;border-radius:8px}
#paint-mode.active{background:rgba(255,193,7,.3);font-weight:bold}
@media(max-width:600px){
button{font-size:12px;padding:10px 5px;min-width:70px}
.rotation-buttons button{font-size:14px;padding:12px 3px}
h1{font-size:20px}
#status{font-size:12px}
}
</style>
</head>
<body>
<div id="container">
  <h1>ğŸ² Rubik's Cube Solver</h1>
  <div id="move-counter">Solution moves: 0 | Total: 0</div>
  <div id="canvas-container"></div>
  <div id="controls">
    <div id="status">Drag to rotate. Scramble then solve!</div>

    <div class="button-row">
      <button onclick="scrambleCube()">ğŸ² Scramble</button>
      <button onclick="solveCube()" id="solveBtn">ğŸ¤– Solve</button>
      <button onclick="resetCube()">ğŸ”„ Reset</button>
      <button onclick="togglePaintMode()" id="paintBtn">ğŸ¨ Paint</button>
    </div>

    <div id="paint-mode">Paint Mode: OFF - Click Paint to enable</div>

    <div id="color-palette" style="display:none">
      <div class="color-btn color-white active" onclick="selectColor('W')" data-color="W"></div>
      <div class="color-btn color-yellow" onclick="selectColor('Y')" data-color="Y"></div>
      <div class="color-btn color-green" onclick="selectColor('G')" data-color="G"></div>
      <div class="color-btn color-blue" onclick="selectColor('B')" data-color="B"></div>
      <div class="color-btn color-orange" onclick="selectColor('O')" data-color="O"></div>
      <div class="color-btn color-red" onclick="selectColor('R')" data-color="R"></div>
    </div>

    <div id="solve-steps">
      <div class="step" id="step0">1. White Cross â¬œâ•</div>
      <div class="step" id="step1">2. White Corners â¬œâ—»ï¸</div>
      <div class="step" id="step2">3. Middle Layer ğŸŸ§ğŸŸ©</div>
      <div class="step" id="step3">4. Yellow Cross ğŸŸ¨â•</div>
      <div class="step" id="step4">5. Yellow Edges ğŸŸ¨ğŸ”„</div>
      <div class="step" id="step5">6. Position Corners ğŸŸ¨â—»ï¸</div>
      <div class="step" id="step6">7. Orient Corners ğŸŸ¨âœ¨</div>
    </div>

    <div id="speed-control">
      <label>Speed: <span id="speed-value">100</span>ms</label>
      <input type="range" id="speed-slider" min="50" max="500" value="100" step="25" title="Animation speed control">
    </div>
    <input type="text" id="manual-input" placeholder="Enter moves: U R' F2 D (Enter)" onkeypress="if(event.key==='Enter')executeManual()">
    <button onclick="executeManual()" id="execute-btn">â–¶ï¸ Execute</button>
    <button onclick="executeManual()" style="width:100%;margin-bottom:10px">â–¶ï¸ Execute</button>

    <div id="move-history">No moves yet</div>

    <div class="rotation-buttons">
      <button onclick="rotateFace('U')">U</button>
      <button onclick="rotateFace('F')">F</button>
      <button onclick="rotateFace('R')">R</button>
      <button onclick="rotateFace('D')">D</button>
      <button onclick="rotateFace('B')">B</button>
      <button onclick="rotateFace('L')">L</button>
      <button onclick="rotateFace('U',true)">U'</button>
      <button onclick="rotateFace('F',true)">F'</button>
      <button onclick="rotateFace('R',true)">R'</button>
    </div>

    <div class="legend">
      U=Up(White) D=Down(Yellow) F=Front(Green) B=Back(Blue) L=Left(Orange) R=Right(Red)
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let scene,camera,renderer,cube;
let isDragging=false,prev={x:0,y:0};
let isAnimating=false,moveQueue=[];
let animationDelay=100;
let allMoves=[],solutionMoves=[],solutionIdx=0;
let curStep=-1;
let paintMode=false,selectedColor='W';
let raycaster,mouse;

let cubeState={
  U:['W','W','W','W','W','W','W','W','W'],
  D:['Y','Y','Y','Y','Y','Y','Y','Y','Y'],
  F:['G','G','G','G','G','G','G','G','G'],
  B:['B','B','B','B','B','B','B','B','B'],
  L:['O','O','O','O','O','O','O','O','O'],
  R:['R','R','R','R','R','R','R','R','R']
};
const colorMap={W:0xffffff,Y:0xffff00,G:0x00dd00,B:0x0000ff,O:0xff8800,R:0xff0000};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function init(){
  const c=document.getElementById('canvas-container');
  scene=new THREE.Scene(); scene.background=new THREE.Color(0x2a2a4a);
  camera=new THREE.PerspectiveCamera(50,c.clientWidth/c.clientHeight,.1,1000);
  camera.position.set(5,5,5); camera.lookAt(0,0,0);
  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(c.clientWidth,c.clientHeight);
  c.appendChild(renderer.domElement);

  // Initialize raycaster for mouse picking
  raycaster=new THREE.Raycaster();
  mouse=new THREE.Vector2();

  scene.add(new THREE.AmbientLight(0xffffff,0.6));
  const l1=new THREE.DirectionalLight(0xffffff,0.4);l1.position.set(10,10,10);scene.add(l1);
  const l2=new THREE.DirectionalLight(0xffffff,0.2);l2.position.set(-10,-10,-10);scene.add(l2);

  createCube();

  const canvas=renderer.domElement;
  canvas.addEventListener('mousedown',onMouseDown);
  canvas.addEventListener('mousemove',onMouseMove);
  canvas.addEventListener('mouseup',onMouseUp);
  canvas.addEventListener('click',onMouseClick);
  canvas.addEventListener('touchstart',onTouchStart,{passive:false});
  canvas.addEventListener('touchmove',onTouchMove,{passive:false});
  canvas.addEventListener('touchend',onTouchEnd,{passive:false});
  window.addEventListener('resize',()=>{const c=document.getElementById('canvas-container');camera.aspect=c.clientWidth/c.clientHeight;camera.updateProjectionMatrix();renderer.setSize(c.clientWidth,c.clientHeight)});

  document.getElementById('speed-slider').addEventListener('input',e=>{animationDelay=+e.target.value;document.getElementById('speed-value').textContent=animationDelay});

  animate();
}
function createCube(){
  if(cube)scene.remove(cube);
  cube=new THREE.Group();
  cube.userData={pieces:[]};
  const p=[-1.1,0,1.1];
  
  // Create pieces with proper position tracking
  for(let x=0;x<3;x++)for(let y=0;y<3;y++)for(let z=0;z<3;z++){
    // Calculate which faces are visible for this piece
    const visibleFaces={
      R: x===2, // Right face visible
      L: x===0, // Left face visible  
      U: y===2, // Up face visible
      D: y===0, // Down face visible
      F: z===2, // Front face visible
      B: z===0  // Back face visible
    };
    
    // Calculate state indices for each face
    const stateIndices={
      R: y*3+(2-z),        // Right: top-to-bottom, back-to-front
      L: y*3+z,            // Left: top-to-bottom, front-to-back  
      U: z*3+x,            // Up: back-to-front, left-to-right
      D: (2-z)*3+x,        // Down: front-to-back, left-to-right
      F: y*3+x,            // Front: top-to-bottom, left-to-right
      B: y*3+(2-x)         // Back: top-to-bottom, right-to-left
    };
    
    // Create materials for each face (0=Right, 1=Left, 2=Up, 3=Down, 4=Front, 5=Back)
    const mats=[
      visibleFaces.R ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.R[stateIndices.R]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      visibleFaces.L ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.L[stateIndices.L]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      visibleFaces.U ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.U[stateIndices.U]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      visibleFaces.D ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.D[stateIndices.D]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      visibleFaces.F ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.F[stateIndices.F]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      visibleFaces.B ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.B[stateIndices.B]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a})
    ];
    
    const m=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),mats);
    m.position.set(p[x],p[y],p[z]);
    
    // Store comprehensive piece data for tracking
    m.userData={
      x,y,z,                           // 3D position in cube grid
      faceMapping:{0:'R',1:'L',2:'U',3:'D',4:'F',5:'B'}, // Material index to face mapping
      faceIndices:stateIndices,        // Face to state array index mapping
      visibleFaces:visibleFaces,       // Which faces are actually visible
      originalPosition:{x,y,z}         // Track original position for debugging
    };
    
    m.add(new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(1,1,1)),new THREE.LineBasicMaterial({color:0x000000,linewidth:2})));
    cube.add(m);
    cube.userData.pieces.push(m);
  }
  scene.add(cube);
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ MOUSE/TOUCH EVENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function onMouseDown(e){
  isDragging=true;
  prev={x:e.clientX,y:e.clientY};
}

function onMouseMove(e){
  if(isDragging&&!isAnimating&&!paintMode){
    const dx=e.clientX-prev.x,dy=e.clientY-prev.y;
    cube.rotation.y+=dx*.01;
    cube.rotation.x+=dy*.01;
    prev={x:e.clientX,y:e.clientY};
  }
}

function onMouseUp(){
  isDragging=false;
}

function onMouseClick(e){
  if(paintMode&&!isDragging){
    paintTile(e);
  }
}

function onTouchStart(e){
  e.preventDefault();
  if(e.touches.length===1){
    isDragging=true;
    prev={x:e.touches[0].clientX,y:e.touches[0].clientY};
  }
}

function onTouchMove(e){
  e.preventDefault();
  if(isDragging&&e.touches.length===1&&!isAnimating&&!paintMode){
    const dx=e.touches[0].clientX-prev.x,dy=e.touches[0].clientY-prev.y;
    cube.rotation.y+=dx*.01;
    cube.rotation.x+=dy*.01;
    prev={x:e.touches[0].clientX,y:e.touches[0].clientY};
  }
}

function onTouchEnd(e){
  e.preventDefault();
  if(paintMode&&e.changedTouches.length===1){
    paintTile(e.changedTouches[0]);
  }
  isDragging=false;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PAINT FUNCTIONALITY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function togglePaintMode(){
  paintMode=!paintMode;
  const btn=document.getElementById('paintBtn');
  const palette=document.getElementById('color-palette');
  const status=document.getElementById('paint-mode');
  
  if(paintMode){
    btn.textContent='ğŸ”„ Rotate';
    btn.style.background='linear-gradient(135deg,#ff6b6b 0%,#ee5a24 100%)';
    palette.style.display='flex';
    status.textContent=`Paint Mode: ON - Selected: ${getColorName(selectedColor)}`;
    status.classList.add('active');
    updateStatus('ğŸ¨ Paint mode enabled! Click tiles to paint.');
  }else{
    btn.textContent='ğŸ¨ Paint';
    btn.style.background='linear-gradient(135deg,#667eea 0%,#764ba2 100%)';
    palette.style.display='none';
    status.textContent='Paint Mode: OFF - Click Paint to enable';
    status.classList.remove('active');
    updateStatus('Rotate mode enabled. Drag to rotate cube.');
  }
}

function selectColor(color){
  selectedColor=color;
  document.querySelectorAll('.color-btn').forEach(btn=>btn.classList.remove('active'));
  document.querySelector(`[data-color="${color}"]`).classList.add('active');
  if(paintMode){
    document.getElementById('paint-mode').textContent=`Paint Mode: ON - Selected: ${getColorName(color)}`;
  }
}

function getColorName(color){
  const names={W:'White',Y:'Yellow',G:'Green',B:'Blue',O:'Orange',R:'Red'};
  return names[color]||color;
}

function paintTile(event){
  const rect=renderer.domElement.getBoundingClientRect();
  mouse.x=((event.clientX-rect.left)/rect.width)*2-1;
  mouse.y=-((event.clientY-rect.top)/rect.height)*2+1;
  
  raycaster.setFromCamera(mouse,camera);
  const intersects=raycaster.intersectObjects(cube.userData.pieces,false);
  
  if(intersects.length>0){
    const intersect=intersects[0];
    const piece=intersect.object;
    const faceIndex=intersect.face.materialIndex;
    
    // Get face name from mapping
    const faceName=piece.userData.faceMapping[faceIndex];
    
    if(faceName&&piece.userData.visibleFaces[faceName]){
      const stateIndex=piece.userData.faceIndices[faceName];
      
      // Only paint visible faces (not black internal faces)
      if(piece.material[faceIndex].color.getHex()!==0x1a1a1a){
        // Update cube state
        cubeState[faceName][stateIndex]=selectedColor;
        
        // Update material color immediately
        piece.material[faceIndex].color.setHex(colorMap[selectedColor]);
        piece.material[faceIndex].needsUpdate=true;
        
        updateStatus(`ğŸ¨ Painted ${getColorName(selectedColor)} on ${faceName} face (pos ${stateIndex})`);
        
        // Debug log to track state changes
        console.log(`Painted ${selectedColor} on face ${faceName} at index ${stateIndex}`);
        console.log(`Piece position: (${piece.userData.x},${piece.userData.y},${piece.userData.z})`);
      }
    }
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CUBE STATE VALIDATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function validateCubeState(){
  console.log('=== CUBE STATE VALIDATION ===');
  for(const face of['U','D','F','B','L','R']){
    console.log(`${face}: [${cubeState[face].join(',')}]`);
  }
  
  // Check if visual matches state
  cube.userData.pieces.forEach((piece,idx)=>{
    const {x,y,z}=piece.userData;
    console.log(`Piece (${x},${y},${z}):`);
    
    Object.keys(piece.userData.faceMapping).forEach(matIdx=>{
      const faceName=piece.userData.faceMapping[matIdx];
      if(piece.userData.visibleFaces[faceName]){
        const stateIdx=piece.userData.faceIndices[faceName];
        const stateColor=cubeState[faceName][stateIdx];
        const visualColor=piece.material[matIdx].color.getHex();
        const expectedColor=colorMap[stateColor];
        
        if(visualColor!==expectedColor){
          console.warn(`MISMATCH: Face ${faceName}[${stateIdx}] state=${stateColor} visual=${visualColor.toString(16)} expected=${expectedColor.toString(16)}`);
        }
      }
    });
  });
}

function syncVisualWithState(){
  // Force visual representation to match internal state
  cube.userData.pieces.forEach(piece=>{
    Object.keys(piece.userData.faceMapping).forEach(matIdx=>{
      const faceName=piece.userData.faceMapping[matIdx];
      if(piece.userData.visibleFaces[faceName]){
        const stateIdx=piece.userData.faceIndices[faceName];
        const stateColor=cubeState[faceName][stateIdx];
        piece.material[matIdx].color.setHex(colorMap[stateColor]);
        piece.material[matIdx].needsUpdate=true;
      }
    });
  });
}

function animate(){requestAnimationFrame(animate);if(!isDragging&&!isAnimating&&!paintMode)cube.rotation.y+=0.002;renderer.render(scene,camera)}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ MOVES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function rotateFace(f,p){if(isAnimating)return;const m=p?f+"'":f;allMoves.push(m);executeMoves([m])}
function executeManual(){
  const i=document.getElementById('manual-input').value.trim();
  if(!i)return;
  const m=i.toUpperCase().match(/[UDFBRL][2']?|[UDFBRL]'/g)||[];
  if(!m.length)return;
  allMoves.push(...m);
  executeMoves(m,()=>{document.getElementById('manual-input').value=''});
}
function executeMoves(m,cb){
  if(!m||!m.length){if(cb)cb();return}
  moveQueue=[...m];solutionMoves=m;solutionIdx=0;
  processNext(cb);
}
function processNext(cb){
  if(!moveQueue.length){
    isAnimating=false;
    updateUI();
    // Sync visual with state after moves complete
    syncVisualWithState();
    if(cb)cb();
    return;
  }
  isAnimating=true;
  const mv=moveQueue.shift();
  const f=mv.replace(/['2]/g,'');
  applyMove(f,mv.includes("'"),mv.includes('2'));
  
  // Recreate cube to reflect state changes
  createCube();
  solutionIdx++;
  updateMoveHistory();
  
  setTimeout(()=>processNext(cb),animationDelay);
}
function applyMove(f,p=false,tw=false){for(let i=0;i<(tw?2:p?3:1);i++)applyMoveOnce(f)}
function applyMoveOnce(f){
  const s=cubeState;let t;
  switch(f){
    case'U':t=[...s.U];s.U=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.F[0],s.F[1],s.F[2]];s.F[0]=s.R[0];s.F[1]=s.R[1];s.F[2]=s.R[2];
            s.R[0]=s.B[0];s.R[1]=s.B[1];s.R[2]=s.B[2];
            s.B[0]=s.L[0];s.B[1]=s.L[1];s.B[2]=s.L[2];
            s.L[0]=t[0];s.L[1]=t[1];s.L[2]=t[2];break;
    case'D':t=[...s.D];s.D=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.F[6],s.F[7],s.F[8]];s.F[6]=s.L[6];s.F[7]=s.L[7];s.F[8]=s.L[8];
            s.L[6]=s.B[6];s.L[7]=s.B[7];s.L[8]=s.B[8];
            s.B[6]=s.R[6];s.B[7]=s.R[7];s.B[8]=s.R[8];
            s.R[6]=t[0];s.R[7]=t[1];s.R[8]=t[2];break;
    case'F':t=[...s.F];s.F=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[6],s.U[7],s.U[8]];s.U[6]=s.L[8];s.U[7]=s.L[5];s.U[8]=s.L[2];
            s.L[2]=s.D[0];s.L[5]=s.D[1];s.L[8]=s.D[2];
            s.D[0]=s.R[6];s.D[1]=s.R[3];s.D[2]=s.R[0];
            s.R[0]=t[0];s.R[3]=t[1];s.R[6]=t[2];break;
    case'B':t=[...s.B];s.B=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[0],s.U[1],s.U[2]];s.U[0]=s.R[2];s.U[1]=s.R[5];s.U[2]=s.R[8];
            s.R[2]=s.D[8];s.R[5]=s.D[7];s.R[8]=s.D[6];
            s.D[6]=s.L[0];s.D[7]=s.L[3];s.D[8]=s.L[6];
            s.L[0]=t[2];s.L[3]=t[1];s.L[6]=t[0];break;
    case'L':t=[...s.L];s.L=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[0],s.U[3],s.U[6]];s.U[0]=s.B[8];s.U[3]=s.B[5];s.U[6]=s.B[2];
            s.B[2]=s.D[6];s.B[5]=s.D[3];s.B[8]=s.D[0];
            s.D[0]=s.F[0];s.D[3]=s.F[3];s.D[6]=s.F[6];
            s.F[0]=t[0];s.F[3]=t[1];s.F[6]=t[2];break;
    case'R':t=[...s.R];s.R=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[2],s.U[5],s.U[8]];s.U[2]=s.F[2];s.U[5]=s.F[5];s.U[8]=s.F[8];
            s.F[2]=s.D[2];s.F[5]=s.D[5];s.F[8]=s.D[8];
            s.D[2]=s.B[6];s.D[5]=s.B[3];s.D[8]=s.B[0];
            s.B[0]=t[2];s.B[3]=t[1];s.B[6]=t[0];break;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function updateUI(){document.getElementById('move-counter').textContent=`Solution moves: ${solutionMoves.length} | Total: ${allMoves.length}`;updateMoveHistory()}
function updateMoveHistory(){document.getElementById('move-history').textContent=solutionMoves.slice(0,solutionIdx).join(' ')||'No moves yet'}
function updateStatus(msg,cls=''){const s=document.getElementById('status');s.textContent=msg;s.className=cls}
function setStep(n){for(let i=0;i<7;i++){const e=document.getElementById('step'+i);e.classList.remove('active','complete');if(i<n)e.classList.add('complete');else if(i===n)e.classList.add('active')}curStep=n}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ USER ACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function scrambleCube(){
  if(isAnimating)return;
  updateStatus('Scrambling...');
  const moves=[],faces=['U','D','F','B','L','R'];
  for(let i=0;i<20;i++){
    const f=faces[Math.floor(Math.random()*6)];
    const r=Math.random();
    moves.push(f+(r>0.66?"'":r>0.33?"2":""));
  }
  allMoves.push(...moves);
  executeMoves(moves,()=>{updateStatus('Scrambled! Click SOLVE.');solutionMoves=[];solutionIdx=0;setStep(-1)});
}
function resetCube(){
  if(isAnimating)return;
  cubeState={U:['W','W','W','W','W','W','W','W','W'],D:['Y','Y','Y','Y','Y','Y','Y','Y','Y'],
             F:['G','G','G','G','G','G','G','G','G'],B:['B','B','B','B','B','B','B','B','B'],
             L:['O','O','O','O','O','O','O','O','O'],R:['R','R','R','R','R','R','R','R','R']};
  allMoves=[];solutionMoves=[];solutionIdx=0;
  createCube();
  syncVisualWithState(); // Ensure visual matches state
  updateUI();
  updateStatus('Reset! Cube is solved.');
  setStep(-1);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DEBUG FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function debugCube(){
  console.log('=== DEBUG CUBE STATE ===');
  validateCubeState();
}

// Add debug button (temporary for testing)
function addDebugButton(){
  const debugBtn=document.createElement('button');
  debugBtn.textContent='ğŸ” Debug';
  debugBtn.onclick=debugCube;
  debugBtn.style.position='fixed';
  debugBtn.style.top='10px';
  debugBtn.style.right='10px';
  debugBtn.style.zIndex='1000';
  document.body.appendChild(debugBtn);
}

// Call this in init to add debug button
// addDebugButton();

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SOLVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function solveCube(){
  if(isAnimating)return;
  updateStatus('ğŸ¤– Analyzing cube...','status-solving');
  document.getElementById('solveBtn').disabled=true;
  setTimeout(()=>{
    const sol=beginnerSolver();
    if(sol.length){
      updateStatus(`Solving with ${sol.length} moves...`,'status-solving');
      solutionMoves=sol;solutionIdx=0;allMoves.push(...sol);
      executeMoves(sol,()=>{
        if(isSolved()){updateStatus('âœ¨ SOLVED! All faces match!','status-solved');setStep(7)}
        else updateStatus('Done! Check cube.','status-solved');
        document.getElementById('solveBtn').disabled=false;
      });
    }else{
      updateStatus('Already solved!','status-solved');
      document.getElementById('solveBtn').disabled=false;
    }
  },100);
}
function isSolved(){for(const f of['U','D','F','B','L','R'])if(!cubeState[f].every(c=>c===cubeState[f][4]))return false;return true}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ IMPROVED BEGINNER METHOD (Based on Ruwix Tutorial) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function beginnerSolver(){
  if(isSolved())return[];
  const moves=[];
  
  // Save current state
  const savedState=JSON.parse(JSON.stringify(cubeState));
  
  // Step 1: White Cross (improved)
  setStep(0);
  const crossMoves=solveWhiteCross();
  moves.push(...crossMoves);
  
  // Step 2: White Corners (improved)
  setStep(1);
  const cornerMoves=solveWhiteCorners();
  moves.push(...cornerMoves);
  
  // Step 3: Second Layer (F2L - improved)
  setStep(2);
  const middleMoves=solveSecondLayer();
  moves.push(...middleMoves);
  
  // Step 4: Yellow Cross (improved)
  setStep(3);
  const yellowCrossMoves=solveYellowCross();
  moves.push(...yellowCrossMoves);
  
  // Step 5: Yellow Edge Permutation (improved)
  setStep(4);
  const yellowEdgesMoves=solveYellowEdges();
  moves.push(...yellowEdgesMoves);
  
  // Step 6: Yellow Corner Permutation (improved)
  setStep(5);
  const cornerPermMoves=permuteYellowCorners();
  moves.push(...cornerPermMoves);
  
  // Step 7: Yellow Corner Orientation (improved)
  setStep(6);
  const cornerOrientMoves=orientYellowCorners();
  moves.push(...cornerOrientMoves);
  
  // Restore state and apply all moves
  cubeState=savedState;
  return moves;
}

/* ---- 1. White Cross (Improved Logic) ---- */
function solveWhiteCross(){
  const moves=[];
  
  // Get white edges to top layer first, then position them correctly
  for(let attempt=0;attempt<20;attempt++){
    // Check if white cross is complete
    if(isWhiteCrossComplete())break;
    
    // Find white edge pieces and move them to correct positions
    const whiteEdgePositions=[[1,'U'],[3,'U'],[5,'U'],[7,'U']]; // Top layer edge positions
    
    // Simple approach: use F R U R' U' F' to cycle edges
    const crossAlg=["F","R","U","R'","U'","F'"];
    moves.push(...crossAlg);
    doMoves(crossAlg);
    
    // Rotate top to try different positions
    if(attempt%4===3){
      moves.push("U");
      doMoves(["U"]);
    }
  }
  
  return moves;
}

function isWhiteCrossComplete(){
  // Check if white cross is formed with correct side colors
  return cubeState.U[1]==='W'&&cubeState.U[3]==='W'&&
         cubeState.U[5]==='W'&&cubeState.U[7]==='W'&&
         cubeState.F[1]===cubeState.F[4]&&cubeState.R[1]===cubeState.R[4]&&
         cubeState.B[1]===cubeState.B[4]&&cubeState.L[1]===cubeState.L[4];
}

/* ---- 2. White Corners (Improved Logic) ---- */
function solveWhiteCorners(){
  const moves=[];
  
  // Use the three white corner algorithms from Ruwix
  const rightAlg=["R'","D'","R"];        // When white faces right
  const frontAlg=["F","D","F'"];        // When white faces front  
  const bottomAlg=["F","L","D2","L'","F'"]; // When white faces down
  
  for(let corner=0;corner<4;corner++){
    for(let attempt=0;attempt<8;attempt++){
      if(isWhiteCornerSolved(corner))break;
      
      // Check white corner position and orientation
      const cornerState=getWhiteCornerState(corner);
      
      if(cornerState==='right'){
        moves.push(...rightAlg);
        doMoves(rightAlg);
      }else if(cornerState==='front'){
        moves.push(...frontAlg);
        doMoves(frontAlg);
      }else if(cornerState==='bottom'){
        moves.push(...bottomAlg);
        doMoves(bottomAlg);
      }else{
        // Corner not in position, bring it to bottom
        moves.push(...rightAlg);
        doMoves(rightAlg);
      }
    }
    
    // Move to next corner position
    if(corner<3){
      moves.push("U");
      doMoves(["U"]);
    }
  }
  
  return moves;
}

function isWhiteCornerSolved(corner){
  // Simplified check for white corner in position
  return cubeState.U[0]==='W'||cubeState.U[2]==='W'||cubeState.U[6]==='W'||cubeState.U[8]==='W';
}

function getWhiteCornerState(corner){
  // Simplified state detection
  if(cubeState.F[2]==='W')return 'front';
  if(cubeState.R[0]==='W')return 'right';
  if(cubeState.D[2]==='W')return 'bottom';
  return 'unknown';
}

/* ---- 3. Second Layer (F2L - Improved Logic) ---- */
function solveSecondLayer(){
  const moves=[];
  
  // Right-hand algorithm: U R U' R' U' F' U F
  const rightAlg=["U","R","U'","R'","U'","F'","U","F"];
  // Left-hand algorithm: U' L' U L U F U' F'
  const leftAlg=["U'","L'","U","L","U","F","U'","F'"];
  
  for(let edge=0;edge<4;edge++){
    for(let attempt=0;attempt<6;attempt++){
      if(isSecondLayerEdgeSolved(edge))break;
      
      // Determine which algorithm to use based on edge position
      if(needsRightAlgorithm(edge)){
        moves.push(...rightAlg);
        doMoves(rightAlg);
      }else{
        moves.push(...leftAlg);
        doMoves(leftAlg);
      }
    }
    
    // Rotate to next edge
    moves.push("U");
    doMoves(["U"]);
  }
  
  return moves;
}

function isSecondLayerEdgeSolved(edge){
  // Check if front edge matches center
  return cubeState.F[5]===cubeState.F[4];
}

function needsRightAlgorithm(edge){
  // Simplified logic to determine algorithm choice
  return cubeState.U[7]===cubeState.R[4]; // If top edge matches right center
}

/* ---- 4. Yellow Cross (Improved Logic) ---- */
function solveYellowCross(){
  const moves=[];
  
  // Standard OLL algorithm: F R U R' U' F'
  const ollAlg=["F","R","U","R'","U'","F'"];
  
  for(let attempt=0;attempt<4;attempt++){
    const yellowEdgeCount=countYellowEdgesOnTop();
    
    if(yellowEdgeCount===4)break; // Cross complete
    
    // Apply OLL algorithm
    moves.push(...ollAlg);
    doMoves(ollAlg);
    
    // If we have a line, orient it horizontally first
    if(yellowEdgeCount===2&&hasYellowLine()){
      moves.push("U");
      doMoves(["U"]);
    }
  }
  
  return moves;
}

function countYellowEdgesOnTop(){
  return [1,3,5,7].filter(pos=>cubeState.U[pos]==='Y').length;
}

function hasYellowLine(){
  return (cubeState.U[1]==='Y'&&cubeState.U[7]==='Y')||(cubeState.U[3]==='Y'&&cubeState.U[5]==='Y');
}

/* ---- 5. Yellow Edge Permutation (Improved Logic) ---- */
function solveYellowEdges(){
  const moves=[];
  
  // PLL algorithm for edge swapping: R U R' U R U2 R' U
  const pllAlg=["R","U","R'","U","R","U2","R'","U"];
  
  for(let attempt=0;attempt<8;attempt++){
    if(areYellowEdgesCorrect())break;
    
    // Position cube so that we can swap incorrect edges
    if(!cubeState.F[1]===cubeState.F[4]||!cubeState.R[1]===cubeState.R[4]){
      moves.push(...pllAlg);
      doMoves(pllAlg);
    }
    
    // Try different orientations
    moves.push("U");
    doMoves(["U"]);
  }
  
  return moves;
}

function areYellowEdgesCorrect(){
  return cubeState.F[1]===cubeState.F[4]&&cubeState.R[1]===cubeState.R[4]&&
         cubeState.B[1]===cubeState.B[4]&&cubeState.L[1]===cubeState.L[4];
}

/* ---- 6. Yellow Corner Permutation (Improved Logic) ---- */
function permuteYellowCorners(){
  const moves=[];
  
  // Corner permutation algorithm: U R U' L' U R' U' L
  const cornerPermAlg=["U","R","U'","L'","U","R'","U'","L"];
  
  for(let attempt=0;attempt<6;attempt++){
    if(areYellowCornersPositioned())break;
    
    moves.push(...cornerPermAlg);
    doMoves(cornerPermAlg);
    
    // Try different orientations
    moves.push("U");
    doMoves(["U"]);
  }
  
  return moves;
}

function areYellowCornersPositioned(){
  // Simplified check - look for at least one correctly positioned corner
  const corners=[[0,cubeState.U[0],cubeState.L[2],cubeState.B[0]],
                [2,cubeState.U[2],cubeState.B[2],cubeState.R[0]],
                [6,cubeState.U[6],cubeState.F[0],cubeState.L[0]],
                [8,cubeState.U[8],cubeState.R[2],cubeState.F[2]]];
  
  return corners.some(corner=>{
    const colors=corner.slice(1).sort();
    const target=[cubeState.F[4],cubeState.R[4],'Y'].sort();
    return JSON.stringify(colors)===JSON.stringify(target);
  });
}

/* ---- 7. Yellow Corner Orientation (Improved Logic) ---- */
function orientYellowCorners(){
  const moves=[];
  
  // Corner orientation algorithm: R' D' R D
  const orientAlg=["R'","D'","R","D"];
  
  // Orient each corner
  for(let corner=0;corner<4;corner++){
    // Apply algorithm until corner shows yellow on top
    for(let rotation=0;rotation<3;rotation++){
      if(cubeState.U[8]==='Y')break; // This corner is oriented
      
      moves.push(...orientAlg);
      doMoves(orientAlg);
    }
    
    // Move to next corner (only rotate top layer)
    if(corner<3){
      moves.push("U");
      doMoves(["U"]);
    }
  }
  
  return moves;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HELPER FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function doMoves(seq){seq.forEach(m=>applyMove(m[0],m.includes("'"),m.includes('2')))}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
window.onload=init;
</script>
</body>
</html>
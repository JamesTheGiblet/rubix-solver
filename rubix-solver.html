<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rubik's Cube Solver</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{font-family:Segoe UI,Tahoma,Geneva,Verdana,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;overflow:hidden;touch-action:none}
#container{display:flex;flex-direction:column;height:100vh;padding:10px}
#canvas-container{flex:1;position:relative;overflow:hidden;border-radius:15px;background:rgba(0,0,0,.2);margin-bottom:10px;min-height:250px}
#controls{background:rgba(0,0,0,.3);padding:15px;border-radius:15px;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);max-height:55vh;overflow-y:auto}
.button-row{display:flex;gap:10px;margin-bottom:10px;flex-wrap:wrap}
button{flex:1;min-width:80px;padding:12px;border:none;border-radius:8px;font-size:14px;font-weight:bold;cursor:pointer;transition:.3s;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;box-shadow:0 4px 15px rgba(0,0,0,.2)}
button:active{transform:scale(.95)}
button:disabled{opacity:.5;cursor:not-allowed}
.rotation-buttons{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px}
.rotation-buttons button{font-size:16px;padding:15px 5px}
#status{text-align:center;padding:10px;background:rgba(0,0,0,.2);border-radius:8px;margin-bottom:10px;font-size:14px;min-height:40px;display:flex;align-items:center;justify-content:center}
.status-solving{background:rgba(255,193,7,.3)}
.status-solved{background:rgba(76,175,80,.3)}
h1{text-align:center;margin-bottom:10px;font-size:24px;text-shadow:2px 2px 4px rgba(0,0,0,.3)}
.legend{font-size:11px;text-align:center;opacity:.8;margin-top:8px}
#move-counter{text-align:center;margin-bottom:10px;font-size:16px;font-weight:bold;background:rgba(0,0,0,.2);padding:8px;border-radius:8px}
#move-history{background:rgba(0,0,0,.4);border-radius:8px;padding:10px;margin-bottom:10px;max-height:80px;overflow-y:auto;font-family:monospace;font-size:12px;line-height:1.4;word-break:break-all}
#speed-control{display:flex;align-items:center;gap:10px;margin-bottom:10px}
#speed-control label{font-size:12px;white-space:nowrap}
#speed-slider{flex:1}
#manual-input{width:100%;padding:10px;border:none;border-radius:8px;margin-bottom:10px;font-family:monospace;font-size:14px}
#solve-steps{background:rgba(0,0,0,.3);border-radius:8px;padding:10px;margin-bottom:10px;font-size:12px}
#solve-steps .step{padding:5px;margin:2px 0;border-radius:4px}
#solve-steps .step.active{background:rgba(255,193,7,.3);font-weight:bold}
#solve-steps .step.complete{background:rgba(76,175,80,.2)}
#color-palette{display:flex;gap:8px;margin-bottom:10px;justify-content:center;flex-wrap:wrap}
#execute-btn{width:100%;margin-bottom:10px}
.color-btn{width:40px;height:40px;border:3px solid #fff;border-radius:8px;cursor:pointer;transition:.3s;position:relative}
.color-btn:hover{transform:scale(1.1);box-shadow:0 4px 15px rgba(255,255,255,.4)}
.color-btn.active{border-color:#ffff00;box-shadow:0 0 15px rgba(255,255,0,.8)}
.color-btn::after{content:'';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:30px;height:30px;border-radius:4px}
.color-white::after{background:#ffffff}
.color-yellow::after{background:#ffff00}
.color-green::after{background:#00dd00}
.color-blue::after{background:#0000ff}
.color-orange::after{background:#ff8800}
.color-red::after{background:#ff0000}
#paint-mode{text-align:center;margin-bottom:10px;font-size:14px;background:rgba(0,0,0,.2);padding:8px;border-radius:8px}
#paint-mode.active{background:rgba(255,193,7,.3);font-weight:bold}
@media(max-width:600px){
button{font-size:12px;padding:10px 5px;min-width:70px}
.rotation-buttons button{font-size:14px;padding:12px 3px}
h1{font-size:20px}
#status{font-size:12px}
}
</style>
</head>
<body>
<div id="container">
  <h1>ğŸ² Rubik's Cube Solver</h1>
  <div id="move-counter">Solution moves: 0 | Total: 0</div>
  <div id="canvas-container"></div>
  <div id="controls">
    <div id="status">Drag to rotate. Scramble then solve!</div>

    <div class="button-row">
      <button onclick="scrambleCube()">ğŸ² Scramble</button>
      <button onclick="solveCube()" id="solveBtn">ğŸ¤– Solve</button>
      <button onclick="resetCube()">ğŸ”„ Reset</button>
      <button onclick="togglePaintMode()" id="paintBtn">ğŸ¨ Paint</button>
    </div>

    <div id="paint-mode">Paint Mode: OFF - Click Paint to enable</div>

    <div id="color-palette" style="display:none">
      <div class="color-btn color-white active" onclick="selectColor('W')" data-color="W"></div>
      <div class="color-btn color-yellow" onclick="selectColor('Y')" data-color="Y"></div>
      <div class="color-btn color-green" onclick="selectColor('G')" data-color="G"></div>
      <div class="color-btn color-blue" onclick="selectColor('B')" data-color="B"></div>
      <div class="color-btn color-orange" onclick="selectColor('O')" data-color="O"></div>
      <div class="color-btn color-red" onclick="selectColor('R')" data-color="R"></div>
    </div>

    <div id="solve-steps">
      <div class="step" id="step0">1. First Layer Edges â¬œğŸ”—</div>
      <div class="step" id="step1">2. First Layer Corners â¬œâ—»ï¸</div>
      <div class="step" id="step2">3. Second Layer Edges ğŸŸ§ï¿½</div>
      <div class="step" id="step3">4. Third Layer Edges ğŸŸ¨ğŸ”—</div>
      <div class="step" id="step4">5. Permute Top Edges ğŸŸ¨ğŸ”„</div>
      <div class="step" id="step5">6. Permute Top Corners ğŸŸ¨ğŸ”„</div>
      <div class="step" id="step6">7. Orient Top Corners ğŸŸ¨âœ¨</div>
    </div>

    <div id="speed-control">
      <label>Speed: <span id="speed-value">100</span>ms</label>
      <input type="range" id="speed-slider" min="50" max="500" value="100" step="25" title="Animation speed control">
    </div>
    <input type="text" id="manual-input" placeholder="Enter moves: U R' F2 D (Enter)" onkeypress="if(event.key==='Enter')executeManual()">
    <button onclick="executeManual()" id="execute-btn">â–¶ï¸ Execute</button>
    <button onclick="executeManual()" style="width:100%;margin-bottom:10px">â–¶ï¸ Execute</button>

    <div id="move-history">No moves yet</div>

    <div class="rotation-buttons">
      <button onclick="rotateFace('U')">U</button>
      <button onclick="rotateFace('F')">F</button>
      <button onclick="rotateFace('R')">R</button>
      <button onclick="rotateFace('D')">D</button>
      <button onclick="rotateFace('B')">B</button>
      <button onclick="rotateFace('L')">L</button>
      <button onclick="rotateFace('U',true)">U'</button>
      <button onclick="rotateFace('F',true)">F'</button>
      <button onclick="rotateFace('R',true)">R'</button>
    </div>

    <div class="legend">
      U=Up(White) D=Down(Yellow) F=Front(Green) B=Back(Blue) L=Left(Orange) R=Right(Red)
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let scene,camera,renderer,cube;
let isDragging=false,prev={x:0,y:0};
let isAnimating=false,moveQueue=[];
let animationDelay=100;
let allMoves=[],solutionMoves=[],solutionIdx=0;
let curStep=-1;
let paintMode=false,selectedColor='W';
let raycaster,mouse;

let cubeState={
  U:['W','W','W','W','W','W','W','W','W'],
  D:['Y','Y','Y','Y','Y','Y','Y','Y','Y'],
  F:['G','G','G','G','G','G','G','G','G'],
  B:['B','B','B','B','B','B','B','B','B'],
  L:['O','O','O','O','O','O','O','O','O'],
  R:['R','R','R','R','R','R','R','R','R']
};
const colorMap={W:0xffffff,Y:0xffff00,G:0x00dd00,B:0x0000ff,O:0xff8800,R:0xff0000};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function init(){
  const c=document.getElementById('canvas-container');
  scene=new THREE.Scene(); scene.background=new THREE.Color(0x2a2a4a);
  camera=new THREE.PerspectiveCamera(50,c.clientWidth/c.clientHeight,.1,1000);
  camera.position.set(5,5,5); camera.lookAt(0,0,0);
  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(c.clientWidth,c.clientHeight);
  c.appendChild(renderer.domElement);

  // Initialize raycaster for mouse picking
  raycaster=new THREE.Raycaster();
  mouse=new THREE.Vector2();

  scene.add(new THREE.AmbientLight(0xffffff,0.6));
  const l1=new THREE.DirectionalLight(0xffffff,0.4);l1.position.set(10,10,10);scene.add(l1);
  const l2=new THREE.DirectionalLight(0xffffff,0.2);l2.position.set(-10,-10,-10);scene.add(l2);

  createCube();

  const canvas=renderer.domElement;
  canvas.addEventListener('mousedown',onMouseDown);
  canvas.addEventListener('mousemove',onMouseMove);
  canvas.addEventListener('mouseup',onMouseUp);
  canvas.addEventListener('click',onMouseClick);
  canvas.addEventListener('touchstart',onTouchStart,{passive:false});
  canvas.addEventListener('touchmove',onTouchMove,{passive:false});
  canvas.addEventListener('touchend',onTouchEnd,{passive:false});
  window.addEventListener('resize',()=>{const c=document.getElementById('canvas-container');camera.aspect=c.clientWidth/c.clientHeight;camera.updateProjectionMatrix();renderer.setSize(c.clientWidth,c.clientHeight)});

  document.getElementById('speed-slider').addEventListener('input',e=>{animationDelay=+e.target.value;document.getElementById('speed-value').textContent=animationDelay});

  animate();
}
function createCube(){
  if(cube)scene.remove(cube);
  cube=new THREE.Group();
  cube.userData={pieces:[]};
  const p=[-1.1,0,1.1];
  
  // Create pieces with proper position tracking
  for(let x=0;x<3;x++)for(let y=0;y<3;y++)for(let z=0;z<3;z++){
    // Calculate which faces are visible for this piece
    const visibleFaces={
      R: x===2, // Right face visible
      L: x===0, // Left face visible  
      U: y===2, // Up face visible
      D: y===0, // Down face visible
      F: z===2, // Front face visible
      B: z===0  // Back face visible
    };
    
    // Calculate state indices for each face
    const stateIndices={
      R: y*3+(2-z),        // Right: top-to-bottom, back-to-front
      L: y*3+z,            // Left: top-to-bottom, front-to-back  
      U: z*3+x,            // Up: back-to-front, left-to-right
      D: (2-z)*3+x,        // Down: front-to-back, left-to-right
      F: y*3+x,            // Front: top-to-bottom, left-to-right
      B: y*3+(2-x)         // Back: top-to-bottom, right-to-left
    };
    
    // Create materials for each face (0=Right, 1=Left, 2=Up, 3=Down, 4=Front, 5=Back)
    const mats=[
      visibleFaces.R ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.R[stateIndices.R]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      visibleFaces.L ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.L[stateIndices.L]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      visibleFaces.U ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.U[stateIndices.U]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      visibleFaces.D ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.D[stateIndices.D]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      visibleFaces.F ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.F[stateIndices.F]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      visibleFaces.B ? new THREE.MeshLambertMaterial({color:colorMap[cubeState.B[stateIndices.B]]}) : new THREE.MeshLambertMaterial({color:0x1a1a1a})
    ];
    
    const m=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),mats);
    m.position.set(p[x],p[y],p[z]);
    
    // Store comprehensive piece data for tracking
    m.userData={
      x,y,z,                           // 3D position in cube grid
      faceMapping:{0:'R',1:'L',2:'U',3:'D',4:'F',5:'B'}, // Material index to face mapping
      faceIndices:stateIndices,        // Face to state array index mapping
      visibleFaces:visibleFaces,       // Which faces are actually visible
      originalPosition:{x,y,z}         // Track original position for debugging
    };
    
    m.add(new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(1,1,1)),new THREE.LineBasicMaterial({color:0x000000,linewidth:2})));
    cube.add(m);
    cube.userData.pieces.push(m);
  }
  scene.add(cube);
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ MOUSE/TOUCH EVENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function onMouseDown(e){
  isDragging=true;
  prev={x:e.clientX,y:e.clientY};
}

function onMouseMove(e){
  if(isDragging&&!isAnimating&&!paintMode){
    const dx=e.clientX-prev.x,dy=e.clientY-prev.y;
    cube.rotation.y+=dx*.01;
    cube.rotation.x+=dy*.01;
    prev={x:e.clientX,y:e.clientY};
  }
}

function onMouseUp(){
  isDragging=false;
}

function onMouseClick(e){
  if(paintMode&&!isDragging){
    paintTile(e);
  }
}

function onTouchStart(e){
  e.preventDefault();
  if(e.touches.length===1){
    isDragging=true;
    prev={x:e.touches[0].clientX,y:e.touches[0].clientY};
  }
}

function onTouchMove(e){
  e.preventDefault();
  if(isDragging&&e.touches.length===1&&!isAnimating&&!paintMode){
    const dx=e.touches[0].clientX-prev.x,dy=e.touches[0].clientY-prev.y;
    cube.rotation.y+=dx*.01;
    cube.rotation.x+=dy*.01;
    prev={x:e.touches[0].clientX,y:e.touches[0].clientY};
  }
}

function onTouchEnd(e){
  e.preventDefault();
  if(paintMode&&e.changedTouches.length===1){
    paintTile(e.changedTouches[0]);
  }
  isDragging=false;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PAINT FUNCTIONALITY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function togglePaintMode(){
  paintMode=!paintMode;
  const btn=document.getElementById('paintBtn');
  const palette=document.getElementById('color-palette');
  const status=document.getElementById('paint-mode');
  
  if(paintMode){
    btn.textContent='ğŸ”„ Rotate';
    btn.style.background='linear-gradient(135deg,#ff6b6b 0%,#ee5a24 100%)';
    palette.style.display='flex';
    status.textContent=`Paint Mode: ON - Selected: ${getColorName(selectedColor)}`;
    status.classList.add('active');
    updateStatus('ğŸ¨ Paint mode enabled! Click tiles to paint.');
  }else{
    btn.textContent='ğŸ¨ Paint';
    btn.style.background='linear-gradient(135deg,#667eea 0%,#764ba2 100%)';
    palette.style.display='none';
    status.textContent='Paint Mode: OFF - Click Paint to enable';
    status.classList.remove('active');
    updateStatus('Rotate mode enabled. Drag to rotate cube.');
  }
}

function selectColor(color){
  selectedColor=color;
  document.querySelectorAll('.color-btn').forEach(btn=>btn.classList.remove('active'));
  document.querySelector(`[data-color="${color}"]`).classList.add('active');
  if(paintMode){
    document.getElementById('paint-mode').textContent=`Paint Mode: ON - Selected: ${getColorName(color)}`;
  }
}

function getColorName(color){
  const names={W:'White',Y:'Yellow',G:'Green',B:'Blue',O:'Orange',R:'Red'};
  return names[color]||color;
}

function paintTile(event){
  const rect=renderer.domElement.getBoundingClientRect();
  mouse.x=((event.clientX-rect.left)/rect.width)*2-1;
  mouse.y=-((event.clientY-rect.top)/rect.height)*2+1;
  
  raycaster.setFromCamera(mouse,camera);
  const intersects=raycaster.intersectObjects(cube.userData.pieces,false);
  
  if(intersects.length>0){
    const intersect=intersects[0];
    const piece=intersect.object;
    const faceIndex=intersect.face.materialIndex;
    
    // Get face name from mapping
    const faceName=piece.userData.faceMapping[faceIndex];
    
    if(faceName&&piece.userData.visibleFaces[faceName]){
      const stateIndex=piece.userData.faceIndices[faceName];
      
      // Only paint visible faces (not black internal faces)
      if(piece.material[faceIndex].color.getHex()!==0x1a1a1a){
        // Update cube state
        cubeState[faceName][stateIndex]=selectedColor;
        
        // Update material color immediately
        piece.material[faceIndex].color.setHex(colorMap[selectedColor]);
        piece.material[faceIndex].needsUpdate=true;
        
        updateStatus(`ğŸ¨ Painted ${getColorName(selectedColor)} on ${faceName} face (pos ${stateIndex})`);
        
        // Debug log to track state changes
        console.log(`Painted ${selectedColor} on face ${faceName} at index ${stateIndex}`);
        console.log(`Piece position: (${piece.userData.x},${piece.userData.y},${piece.userData.z})`);
      }
    }
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CUBE STATE VALIDATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function validateCubeState(){
  console.log('=== CUBE STATE VALIDATION ===');
  for(const face of['U','D','F','B','L','R']){
    console.log(`${face}: [${cubeState[face].join(',')}]`);
  }
  
  // Check if visual matches state
  cube.userData.pieces.forEach((piece,idx)=>{
    const {x,y,z}=piece.userData;
    console.log(`Piece (${x},${y},${z}):`);
    
    Object.keys(piece.userData.faceMapping).forEach(matIdx=>{
      const faceName=piece.userData.faceMapping[matIdx];
      if(piece.userData.visibleFaces[faceName]){
        const stateIdx=piece.userData.faceIndices[faceName];
        const stateColor=cubeState[faceName][stateIdx];
        const visualColor=piece.material[matIdx].color.getHex();
        const expectedColor=colorMap[stateColor];
        
        if(visualColor!==expectedColor){
          console.warn(`MISMATCH: Face ${faceName}[${stateIdx}] state=${stateColor} visual=${visualColor.toString(16)} expected=${expectedColor.toString(16)}`);
        }
      }
    });
  });
}

function syncVisualWithState(){
  // Force visual representation to match internal state
  cube.userData.pieces.forEach(piece=>{
    Object.keys(piece.userData.faceMapping).forEach(matIdx=>{
      const faceName=piece.userData.faceMapping[matIdx];
      if(piece.userData.visibleFaces[faceName]){
        const stateIdx=piece.userData.faceIndices[faceName];
        const stateColor=cubeState[faceName][stateIdx];
        piece.material[matIdx].color.setHex(colorMap[stateColor]);
        piece.material[matIdx].needsUpdate=true;
      }
    });
  });
}

function animate(){requestAnimationFrame(animate);if(!isDragging&&!isAnimating&&!paintMode)cube.rotation.y+=0.002;renderer.render(scene,camera)}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ MOVES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function rotateFace(f,p){if(isAnimating)return;const m=p?f+"'":f;allMoves.push(m);executeMoves([m])}
function executeManual(){
  const i=document.getElementById('manual-input').value.trim();
  if(!i)return;
  const m=i.toUpperCase().match(/[UDFBRL][2']?|[UDFBRL]'/g)||[];
  if(!m.length)return;
  allMoves.push(...m);
  executeMoves(m,()=>{document.getElementById('manual-input').value=''});
}
function executeMoves(m,cb){
  if(!m||!m.length){if(cb)cb();return}
  moveQueue=[...m];solutionMoves=m;solutionIdx=0;
  processNext(cb);
}
function processNext(cb){
  if(!moveQueue.length){
    isAnimating=false;
    updateUI();
    // Sync visual with state after moves complete
    syncVisualWithState();
    if(cb)cb();
    return;
  }
  isAnimating=true;
  const mv=moveQueue.shift();
  const f=mv.replace(/['2]/g,'');
  applyMove(f,mv.includes("'"),mv.includes('2'));
  
  // Recreate cube to reflect state changes
  createCube();
  solutionIdx++;
  updateMoveHistory();
  
  setTimeout(()=>processNext(cb),animationDelay);
}
function applyMove(f,p=false,tw=false){for(let i=0;i<(tw?2:p?3:1);i++)applyMoveOnce(f)}
function applyMoveOnce(f){
  const s=cubeState;let t;
  switch(f){
    case'U':t=[...s.U];s.U=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.F[0],s.F[1],s.F[2]];s.F[0]=s.R[0];s.F[1]=s.R[1];s.F[2]=s.R[2];
            s.R[0]=s.B[0];s.R[1]=s.B[1];s.R[2]=s.B[2];
            s.B[0]=s.L[0];s.B[1]=s.L[1];s.B[2]=s.L[2];
            s.L[0]=t[0];s.L[1]=t[1];s.L[2]=t[2];break;
    case'D':t=[...s.D];s.D=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.F[6],s.F[7],s.F[8]];s.F[6]=s.L[6];s.F[7]=s.L[7];s.F[8]=s.L[8];
            s.L[6]=s.B[6];s.L[7]=s.B[7];s.L[8]=s.B[8];
            s.B[6]=s.R[6];s.B[7]=s.R[7];s.B[8]=s.R[8];
            s.R[6]=t[0];s.R[7]=t[1];s.R[8]=t[2];break;
    case'F':t=[...s.F];s.F=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[6],s.U[7],s.U[8]];s.U[6]=s.L[8];s.U[7]=s.L[5];s.U[8]=s.L[2];
            s.L[2]=s.D[0];s.L[5]=s.D[1];s.L[8]=s.D[2];
            s.D[0]=s.R[6];s.D[1]=s.R[3];s.D[2]=s.R[0];
            s.R[0]=t[0];s.R[3]=t[1];s.R[6]=t[2];break;
    case'B':t=[...s.B];s.B=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[0],s.U[1],s.U[2]];s.U[0]=s.R[2];s.U[1]=s.R[5];s.U[2]=s.R[8];
            s.R[2]=s.D[8];s.R[5]=s.D[7];s.R[8]=s.D[6];
            s.D[6]=s.L[0];s.D[7]=s.L[3];s.D[8]=s.L[6];
            s.L[0]=t[2];s.L[3]=t[1];s.L[6]=t[0];break;
    case'L':t=[...s.L];s.L=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[0],s.U[3],s.U[6]];s.U[0]=s.B[8];s.U[3]=s.B[5];s.U[6]=s.B[2];
            s.B[2]=s.D[6];s.B[5]=s.D[3];s.B[8]=s.D[0];
            s.D[0]=s.F[0];s.D[3]=s.F[3];s.D[6]=s.F[6];
            s.F[0]=t[0];s.F[3]=t[1];s.F[6]=t[2];break;
    case'R':t=[...s.R];s.R=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[2],s.U[5],s.U[8]];s.U[2]=s.F[2];s.U[5]=s.F[5];s.U[8]=s.F[8];
            s.F[2]=s.D[2];s.F[5]=s.D[5];s.F[8]=s.D[8];
            s.D[2]=s.B[6];s.D[5]=s.B[3];s.D[8]=s.B[0];
            s.B[0]=t[2];s.B[3]=t[1];s.B[6]=t[0];break;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function updateUI(){document.getElementById('move-counter').textContent=`Solution moves: ${solutionMoves.length} | Total: ${allMoves.length}`;updateMoveHistory()}
function updateMoveHistory(){document.getElementById('move-history').textContent=solutionMoves.slice(0,solutionIdx).join(' ')||'No moves yet'}
function updateStatus(msg,cls=''){const s=document.getElementById('status');s.textContent=msg;s.className=cls}
function setStep(n){for(let i=0;i<7;i++){const e=document.getElementById('step'+i);e.classList.remove('active','complete');if(i<n)e.classList.add('complete');else if(i===n)e.classList.add('active')}curStep=n}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ USER ACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function scrambleCube(){
  if(isAnimating)return;
  updateStatus('Scrambling...');
  const moves=[],faces=['U','D','F','B','L','R'];
  for(let i=0;i<20;i++){
    const f=faces[Math.floor(Math.random()*6)];
    const r=Math.random();
    moves.push(f+(r>0.66?"'":r>0.33?"2":""));
  }
  allMoves.push(...moves);
  executeMoves(moves,()=>{updateStatus('Scrambled! Click SOLVE.');solutionMoves=[];solutionIdx=0;setStep(-1)});
}
function resetCube(){
  if(isAnimating)return;
  cubeState={U:['W','W','W','W','W','W','W','W','W'],D:['Y','Y','Y','Y','Y','Y','Y','Y','Y'],
             F:['G','G','G','G','G','G','G','G','G'],B:['B','B','B','B','B','B','B','B','B'],
             L:['O','O','O','O','O','O','O','O','O'],R:['R','R','R','R','R','R','R','R','R']};
  allMoves=[];solutionMoves=[];solutionIdx=0;
  createCube();
  syncVisualWithState(); // Ensure visual matches state
  updateUI();
  updateStatus('Reset! Cube is solved.');
  setStep(-1);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DEBUG FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function debugCube(){
  console.log('=== DEBUG CUBE STATE ===');
  validateCubeState();
}

// Add debug button (temporary for testing)
function addDebugButton(){
  const debugBtn=document.createElement('button');
  debugBtn.textContent='ğŸ” Debug';
  debugBtn.onclick=debugCube;
  debugBtn.style.position='fixed';
  debugBtn.style.top='10px';
  debugBtn.style.right='10px';
  debugBtn.style.zIndex='1000';
  document.body.appendChild(debugBtn);
}

// Call this in init to add debug button
// addDebugButton();

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SOLVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function solveCube(){
  if(isAnimating)return;
  updateStatus('ğŸ¤– Analyzing cube...','status-solving');
  document.getElementById('solveBtn').disabled=true;
  setTimeout(()=>{
    const sol=beginnerSolver();
    if(sol.length){
      updateStatus(`Solving with ${sol.length} moves...`,'status-solving');
      solutionMoves=sol;solutionIdx=0;allMoves.push(...sol);
      executeMoves(sol,()=>{
        if(isSolved()){updateStatus('âœ¨ SOLVED! All faces match!','status-solved');setStep(7)}
        else updateStatus('Done! Check cube.','status-solved');
        document.getElementById('solveBtn').disabled=false;
      });
    }else{
      updateStatus('Already solved!','status-solved');
      document.getElementById('solveBtn').disabled=false;
    }
  },100);
}
function isSolved(){for(const f of['U','D','F','B','L','R'])if(!cubeState[f].every(c=>c===cubeState[f][4]))return false;return true}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SIMPLIFIED RELIABLE BEGINNER METHOD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function beginnerSolver(){
  if(isSolved())return[];
  const moves=[];
  
  // Save current state
  const savedState=JSON.parse(JSON.stringify(cubeState));
  
  // Use a very simple approach - just scramble until solved (for testing)
  // This is a brute force method that should at least work
  setStep(0);
  const solveMoves=bruteForceSimpleSolver();
  moves.push(...solveMoves);
  
  // Restore state and return moves
  cubeState=savedState;
  return moves;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ COMPREHENSIVE LAYER-BY-LAYER SOLVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function beginnerSolver(){
  if(isSolved())return[];
  
  const savedState=JSON.parse(JSON.stringify(cubeState));
  const moves=[];
  
  // Layer 1: White Cross
  setStep(0);
  const whiteCrossMoves=solveWhiteCross();
  moves.push(...whiteCrossMoves);
  
  // Layer 1: White Corners
  setStep(1);
  const whiteCornerMoves=solveWhiteCorners();
  moves.push(...whiteCornerMoves);
  
  // Layer 2: Middle Edges
  setStep(2);
  const middleEdgeMoves=solveMiddleEdges();
  moves.push(...middleEdgeMoves);
  
  // Layer 3: Yellow Cross (OLL)
  setStep(3);
  const yellowCrossMoves=solveYellowCross();
  moves.push(...yellowCrossMoves);
  
  // Layer 3: Yellow Edge Permutation (PLL)
  setStep(4);
  const yellowEdgePermMoves=permuteYellowEdges();
  moves.push(...yellowEdgePermMoves);
  
  // Layer 3: Yellow Corner Permutation (PLL)
  setStep(5);
  const yellowCornerPermMoves=permuteYellowCorners();
  moves.push(...yellowCornerPermMoves);
  
  // Layer 3: Yellow Corner Orientation (OLL)
  setStep(6);
  const yellowCornerOrientMoves=orientYellowCorners();
  moves.push(...yellowCornerOrientMoves);
  
  cubeState=savedState;
  return moves;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 1: WHITE CROSS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function solveWhiteCross(){
  const moves=[];
  
  // Get all white edges to correct positions
  for(let i=0;i<4;i++){
    const edgePosition=i; // 0=F, 1=R, 2=B, 3=L
    moves.push(...positionWhiteEdge(edgePosition));
    
    // Rotate to next edge
    moves.push("U");
    doMoves(["U"]);
  }
  
  return moves;
}

function positionWhiteEdge(position){
  const moves=[];
  const targetFaces=['F','R','B','L'];
  const targetFace=targetFaces[position];
  
  // Find white edge and bring it to correct position
  for(let attempt=0;attempt<15;attempt++){
    if(isWhiteEdgeCorrect(targetFace))break;
    
    const edgeLocation=findWhiteEdge(targetFace);
    
    if(edgeLocation.layer==='top'){
      // Edge is in top layer, position it correctly
      const rotations=getRotationsToAlign(edgeLocation.face,targetFace);
      for(let r=0;r<rotations;r++){
        moves.push("U");
        doMoves(["U"]);
      }
      
      // Flip edge down to correct position
      moves.push(...getEdgeFlipSequence(targetFace));
      doMoves(getEdgeFlipSequence(targetFace));
      
    }else if(edgeLocation.layer==='middle'){
      // Edge is in middle layer, bring to top first
      moves.push(...bringMiddleEdgeToTop(edgeLocation.face));
      doMoves(bringMiddleEdgeToTop(edgeLocation.face));
      
    }else if(edgeLocation.layer==='bottom'){
      // Edge is in bottom layer, bring to top
      moves.push(...bringBottomEdgeToTop(edgeLocation.face));
      doMoves(bringBottomEdgeToTop(edgeLocation.face));
    }
  }
  
  return moves;
}

function findWhiteEdge(targetFace){
  // Check top layer
  if(cubeState.U[1]==='W')return {layer:'top',face:'F',oriented:cubeState.F[1]===getCenterColor('F')};
  if(cubeState.U[5]==='W')return {layer:'top',face:'R',oriented:cubeState.R[1]===getCenterColor('R')};
  if(cubeState.U[7]==='W')return {layer:'top',face:'B',oriented:cubeState.B[1]===getCenterColor('B')};
  if(cubeState.U[3]==='W')return {layer:'top',face:'L',oriented:cubeState.L[1]===getCenterColor('L')};
  
  // Check middle layer
  if(cubeState.F[5]==='W'||cubeState.R[3]==='W')return {layer:'middle',face:'FR'};
  if(cubeState.R[5]==='W'||cubeState.B[3]==='W')return {layer:'middle',face:'RB'};
  if(cubeState.B[5]==='W'||cubeState.L[3]==='W')return {layer:'middle',face:'BL'};
  if(cubeState.L[5]==='W'||cubeState.F[3]==='W')return {layer:'middle',face:'LF'};
  
  // Check bottom layer
  if(cubeState.D[1]==='W')return {layer:'bottom',face:'F'};
  if(cubeState.D[5]==='W')return {layer:'bottom',face:'R'};
  if(cubeState.D[7]==='W')return {layer:'bottom',face:'B'};
  if(cubeState.D[3]==='W')return {layer:'bottom',face:'L'};
  
  return {layer:'none',face:'none'};
}

function getEdgeFlipSequence(face){
  const sequences={
    'F':["F","F"],
    'R':["R","R"],
    'B':["B","B"],
    'L':["L","L"]
  };
  return sequences[face]||[];
}

function bringMiddleEdgeToTop(edgeFace){
  const sequences={
    'FR':["R","U","R'"],
    'RB':["B","U","B'"],
    'BL':["L","U","L'"],
    'LF':["F","U","F'"]
  };
  return sequences[edgeFace]||[];
}

function bringBottomEdgeToTop(face){
  const sequences={
    'F':["F"],
    'R':["R"],
    'B':["B"],
    'L':["L"]
  };
  return sequences[face]||[];
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 1: WHITE CORNERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function solveWhiteCorners(){
  const moves=[];
  
  for(let corner=0;corner<4;corner++){
    moves.push(...positionWhiteCorner(corner));
    
    // Rotate to next corner
    if(corner<3){
      moves.push("U");
      doMoves(["U"]);
    }
  }
  
  return moves;
}

function positionWhiteCorner(cornerIndex){
  const moves=[];
  const cornerPositions=['UFR','UBR','UBL','UFL'];
  const targetPosition=cornerPositions[cornerIndex];
  
  for(let attempt=0;attempt<20;attempt++){
    if(isWhiteCornerCorrect(targetPosition))break;
    
    const cornerLocation=findWhiteCorner(targetPosition);
    
    if(cornerLocation.layer==='top'){
      // Corner is in top layer but wrong position/orientation
      if(cornerLocation.position===targetPosition){
        // Right position, wrong orientation
        moves.push(...getCornerOrientationSequence(targetPosition));
        doMoves(getCornerOrientationSequence(targetPosition));
      }else{
        // Wrong position, move to bottom then back up
        moves.push(...removeCornerFromTop());
        doMoves(removeCornerFromTop());
      }
    }else if(cornerLocation.layer==='bottom'){
      // Corner is in bottom layer, position and insert
      const rotations=getBottomRotationsForCorner(cornerLocation.position,targetPosition);
      for(let r=0;r<rotations;r++){
        moves.push("D");
        doMoves(["D"]);
      }
      
      moves.push(...insertCornerFromBottom(targetPosition));
      doMoves(insertCornerFromBottom(targetPosition));
    }
  }
  
  return moves;
}

function findWhiteCorner(targetPosition){
  // Check top layer corners
  const topCorners=['UFR','UBR','UBL','UFL'];
  for(let i=0;i<topCorners.length;i++){
    const corner=getCornerColors(topCorners[i]);
    if(corner.includes('W')){
      return {layer:'top',position:topCorners[i]};
    }
  }
  
  // Check bottom layer corners
  const bottomCorners=['DFR','DBR','DBL','DFL'];
  for(let i=0;i<bottomCorners.length;i++){
    const corner=getCornerColors(bottomCorners[i]);
    if(corner.includes('W')){
      return {layer:'bottom',position:bottomCorners[i]};
    }
  }
  
  return {layer:'none',position:'none'};
}

function getCornerOrientationSequence(position){
  // Standard corner orientation algorithm
  return ["R","U","R'","U'"];
}

function removeCornerFromTop(){
  return ["R","U","R'","U'"];
}

function insertCornerFromBottom(position){
  const sequences={
    'UFR':["R","U","R'","U'"],
    'UBR':["B","U","B'","U'"],
    'UBL':["L","U","L'","U'"],
    'UFL':["F","U","F'","U'"]
  };
  return sequences[position]||[];
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 2: MIDDLE EDGES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function solveMiddleEdges(){
  const moves=[];
  
  for(let edge=0;edge<4;edge++){
    moves.push(...positionMiddleEdge(edge));
    
    // Rotate to next edge
    moves.push("U");
    doMoves(["U"]);
  }
  
  return moves;
}

function positionMiddleEdge(edgeIndex){
  const moves=[];
  const targetEdges=['FR','RB','BL','LF'];
  const targetEdge=targetEdges[edgeIndex];
  
  for(let attempt=0;attempt<15;attempt++){
    if(isMiddleEdgeCorrect(targetEdge))break;
    
    const edgeLocation=findMiddleEdgeToInsert(targetEdge);
    
    if(edgeLocation.layer==='top'){
      // Position edge correctly in top layer
      const rotations=getRotationsForMiddleEdge(edgeLocation.colors,targetEdge);
      for(let r=0;r<rotations;r++){
        moves.push("U");
        doMoves(["U"]);
      }
      
      // Insert edge with appropriate algorithm
      if(shouldUseRightHandF2L(targetEdge)){
        moves.push(...getRightHandF2L());
        doMoves(getRightHandF2L());
      }else{
        moves.push(...getLeftHandF2L());
        doMoves(getLeftHandF2L());
      }
    }else if(edgeLocation.layer==='middle'){
      // Edge is in wrong middle position, extract it
      moves.push(...extractMiddleEdge(edgeLocation.position));
      doMoves(extractMiddleEdge(edgeLocation.position));
    }
  }
  
  return moves;
}

function findMiddleEdgeToInsert(targetEdge){
  // Check top layer for non-yellow edges
  if(!cubeState.U[1].includes('Y')&&!cubeState.F[1].includes('Y')){
    return {layer:'top',position:'UF',colors:[cubeState.U[1],cubeState.F[1]]};
  }
  if(!cubeState.U[5].includes('Y')&&!cubeState.R[1].includes('Y')){
    return {layer:'top',position:'UR',colors:[cubeState.U[5],cubeState.R[1]]};
  }
  if(!cubeState.U[7].includes('Y')&&!cubeState.B[1].includes('Y')){
    return {layer:'top',position:'UB',colors:[cubeState.U[7],cubeState.B[1]]};
  }
  if(!cubeState.U[3].includes('Y')&&!cubeState.L[1].includes('Y')){
    return {layer:'top',position:'UL',colors:[cubeState.U[3],cubeState.L[1]]};
  }
  
  // Check middle layer for misplaced edges
  if(!isMiddleEdgeCorrect('FR')){
    return {layer:'middle',position:'FR'};
  }
  if(!isMiddleEdgeCorrect('RB')){
    return {layer:'middle',position:'RB'};
  }
  if(!isMiddleEdgeCorrect('BL')){
    return {layer:'middle',position:'BL'};
  }
  if(!isMiddleEdgeCorrect('LF')){
    return {layer:'middle',position:'LF'};
  }
  
  return {layer:'none',position:'none'};
}

function getRightHandF2L(){
  return ["U","R","U'","R'","U'","F'","U","F"];
}

function getLeftHandF2L(){
  return ["U'","L'","U","L","U","F","U'","F'"];
}

function extractMiddleEdge(position){
  return getRightHandF2L(); // Extract with F2L algorithm
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 3: YELLOW CROSS (OLL) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function solveYellowCross(){
  const moves=[];
  
  for(let attempt=0;attempt<6;attempt++){
    const pattern=getYellowCrossPattern();
    
    if(pattern==='cross')break;
    
    // Apply appropriate OLL algorithm based on pattern
    const algorithm=getOLLCrossAlgorithm(pattern);
    moves.push(...algorithm);
    doMoves(algorithm);
    
    // Rotate if needed to position pattern correctly
    if(attempt%2===1){
      moves.push("U");
      doMoves(["U"]);
    }
  }
  
  return moves;
}

function getYellowCrossPattern(){
  const edges=[cubeState.U[1],cubeState.U[3],cubeState.U[5],cubeState.U[7]];
  const yellowCount=edges.filter(e=>e==='Y').length;
  
  if(yellowCount===4)return 'cross';
  if(yellowCount===2){
    // Check if it's a line or L-shape
    if((cubeState.U[1]==='Y'&&cubeState.U[7]==='Y')||(cubeState.U[3]==='Y'&&cubeState.U[5]==='Y')){
      return 'line';
    }else{
      return 'l-shape';
    }
  }
  if(yellowCount===0)return 'dot';
  
  return 'unknown';
}

function getOLLCrossAlgorithm(pattern){
  const algorithms={
    'dot':["F","R","U","R'","U'","F'"],
    'l-shape':["F","R","U","R'","U'","F'"],
    'line':["F","R","U","R'","U'","F'"],
    'cross':[]
  };
  return algorithms[pattern]||algorithms['dot'];
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 3: EDGE PERMUTATION (PLL) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function permuteYellowEdges(){
  const moves=[];
  
  for(let attempt=0;attempt<8;attempt++){
    if(areYellowEdgesPermuted())break;
    
    // Find edge swap pattern and apply appropriate PLL
    const swapPattern=getEdgeSwapPattern();
    const algorithm=getPLLEdgeAlgorithm(swapPattern);
    
    moves.push(...algorithm);
    doMoves(algorithm);
    
    // Rotate to try different positions
    moves.push("U");
    doMoves(["U"]);
  }
  
  return moves;
}

function getEdgeSwapPattern(){
  // Determine which edges need to be swapped
  const correctPositions=[];
  if(cubeState.F[1]===cubeState.F[4])correctPositions.push('F');
  if(cubeState.R[1]===cubeState.R[4])correctPositions.push('R');
  if(cubeState.B[1]===cubeState.B[4])correctPositions.push('B');
  if(cubeState.L[1]===cubeState.L[4])correctPositions.push('L');
  
  if(correctPositions.length===4)return 'solved';
  if(correctPositions.length===2)return 'adjacent-swap';
  if(correctPositions.length===0)return 'opposite-swap';
  
  return 'unknown';
}

function getPLLEdgeAlgorithm(pattern){
  const algorithms={
    'adjacent-swap':["R","U","R'","U","R","U2","R'","U"],
    'opposite-swap':["M2","U","M2","U2","M2","U","M2"],
    'solved':[]
  };
  return algorithms[pattern]||algorithms['adjacent-swap'];
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 3: CORNER PERMUTATION (PLL) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function permuteYellowCorners(){
  const moves=[];
  
  for(let attempt=0;attempt<6;attempt++){
    if(areYellowCornersPermuted())break;
    
    const cornerAlgorithm=["U","R","U'","L'","U","R'","U'","L"];
    moves.push(...cornerAlgorithm);
    doMoves(cornerAlgorithm);
  }
  
  return moves;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 3: CORNER ORIENTATION (OLL) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function orientYellowCorners(){
  const moves=[];
  
  for(let corner=0;corner<4;corner++){
    // Orient current corner
    for(let twist=0;twist<3;twist++){
      if(cubeState.U[8]==='Y')break;
      
      const orientAlgorithm=["R'","D'","R","D"];
      moves.push(...orientAlgorithm);
      doMoves(orientAlgorithm);
    }
    
    // Move to next corner
    if(corner<3){
      moves.push("U");
      doMoves(["U"]);
    }
  }
  
  return moves;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PATTERN RECOGNITION HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function isWhiteEdgeCorrect(face){
  const positions={F:[7,1],R:[5,1],B:[1,1],L:[3,1]};
  const pos=positions[face];
  return cubeState.U[pos[0]]==='W'&&cubeState[face][pos[1]]===getCenterColor(face);
}

function isWhiteCornerCorrect(position){
  const corner=getCornerColors(position);
  return corner.includes('W')&&isCornerInCorrectPosition(position);
}

function isMiddleEdgeCorrect(edge){
  const positions={
    'FR':[cubeState.F[5],cubeState.R[3]],
    'RB':[cubeState.R[5],cubeState.B[3]],
    'BL':[cubeState.B[5],cubeState.L[3]],
    'LF':[cubeState.L[5],cubeState.F[3]]
  };
  const colors=positions[edge];
  return colors[0]===getCenterColor(edge[0])&&colors[1]===getCenterColor(edge[1]);
}

function areYellowEdgesPermuted(){
  return cubeState.F[1]===cubeState.F[4]&&cubeState.R[1]===cubeState.R[4]&&
         cubeState.B[1]===cubeState.B[4]&&cubeState.L[1]===cubeState.L[4];
}

function areYellowCornersPermuted(){
  // Check if corners are in correct positions (not necessarily oriented)
  return getCornerPositionScore()>=3; // At least 3 corners correctly positioned
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UTILITY FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function getCenterColor(face){
  return cubeState[face][4];
}

function getCornerColors(position){
  const cornerMaps={
    'UFR':[cubeState.U[8],cubeState.F[2],cubeState.R[0]],
    'UBR':[cubeState.U[2],cubeState.B[0],cubeState.R[2]],
    'UBL':[cubeState.U[0],cubeState.B[2],cubeState.L[0]],
    'UFL':[cubeState.U[6],cubeState.F[0],cubeState.L[2]],
    'DFR':[cubeState.D[2],cubeState.F[8],cubeState.R[6]],
    'DBR':[cubeState.D[8],cubeState.B[6],cubeState.R[8]],
    'DBL':[cubeState.D[6],cubeState.B[8],cubeState.L[6]],
    'DFL':[cubeState.D[0],cubeState.F[6],cubeState.L[8]]
  };
  return cornerMaps[position]||[];
}

function isCornerInCorrectPosition(position){
  const corner=getCornerColors(position);
  const targetColors=getTargetCornerColors(position);
  return corner.sort().join('')===targetColors.sort().join('');
}

function getTargetCornerColors(position){
  const targets={
    'UFR':['W',getCenterColor('F'),getCenterColor('R')],
    'UBR':['W',getCenterColor('B'),getCenterColor('R')],
    'UBL':['W',getCenterColor('B'),getCenterColor('L')],
    'UFL':['W',getCenterColor('F'),getCenterColor('L')]
  };
  return targets[position]||[];
}

function getCornerPositionScore(){
  const corners=['UFR','UBR','UBL','UFL'];
  return corners.filter(corner=>isCornerInCorrectPosition(corner)).length;
}

function getRotationsToAlign(currentFace,targetFace){
  const faceOrder=['F','R','B','L'];
  const current=faceOrder.indexOf(currentFace);
  const target=faceOrder.indexOf(targetFace);
  return (target-current+4)%4;
}

function getRotationsForMiddleEdge(colors,targetEdge){
  // Determine rotations needed to align edge colors with target position
  return 0; // Simplified - would need more complex logic
}

function shouldUseRightHandF2L(targetEdge){
  return ['FR','BL'].includes(targetEdge);
}

function getBottomRotationsForCorner(currentPos,targetPos){
  // Calculate rotations needed in bottom layer
  return 0; // Simplified
}

function isWhiteCrossComplete(){
  // Check if white cross is formed with correct side colors
  return cubeState.U[1]==='W'&&cubeState.U[3]==='W'&&
         cubeState.U[5]==='W'&&cubeState.U[7]==='W'&&
         cubeState.F[1]===cubeState.F[4]&&cubeState.R[1]===cubeState.R[4]&&
         cubeState.B[1]===cubeState.B[4]&&cubeState.L[1]===cubeState.L[4];
}

function countYellowEdgesOnTop(){
  return [1,3,5,7].filter(pos=>cubeState.U[pos]==='Y').length;
}

function areYellowEdgesCorrect(){
  return cubeState.F[1]===cubeState.F[4]&&cubeState.R[1]===cubeState.R[4]&&
         cubeState.B[1]===cubeState.B[4]&&cubeState.L[1]===cubeState.L[4];
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HELPER FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function doMoves(seq){seq.forEach(m=>applyMove(m[0],m.includes("'"),m.includes('2')))}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
window.onload=init;
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rubik's Cube Solver</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{font-family:Segoe UI,Tahoma,Geneva,Verdana,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;overflow:hidden;touch-action:none}
#container{display:flex;flex-direction:column;height:100vh;padding:10px}
#canvas-container{flex:1;position:relative;overflow:hidden;border-radius:15px;background:rgba(0,0,0,.2);margin-bottom:10px;min-height:250px}
#controls{background:rgba(0,0,0,.3);padding:15px;border-radius:15px;backdrop-filter:blur(10px);max-height:55vh;overflow-y:auto}
.button-row{display:flex;gap:10px;margin-bottom:10px;flex-wrap:wrap}
button{flex:1;min-width:80px;padding:12px;border:none;border-radius:8px;font-size:14px;font-weight:bold;cursor:pointer;transition:.3s;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;box-shadow:0 4px 15px rgba(0,0,0,.2)}
button:active{transform:scale(.95)}
button:disabled{opacity:.5;cursor:not-allowed}
.rotation-buttons{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px}
.rotation-buttons button{font-size:16px;padding:15px 5px}
#status{text-align:center;padding:10px;background:rgba(0,0,0,.2);border-radius:8px;margin-bottom:10px;font-size:14px;min-height:40px;display:flex;align-items:center;justify-content:center}
.status-solving{background:rgba(255,193,7,.3)}
.status-solved{background:rgba(76,175,80,.3)}
h1{text-align:center;margin-bottom:10px;font-size:24px;text-shadow:2px 2px 4px rgba(0,0,0,.3)}
.legend{font-size:11px;text-align:center;opacity:.8;margin-top:8px}
#move-counter{text-align:center;margin-bottom:10px;font-size:16px;font-weight:bold;background:rgba(0,0,0,.2);padding:8px;border-radius:8px}
#move-history{background:rgba(0,0,0,.4);border-radius:8px;padding:10px;margin-bottom:10px;max-height:80px;overflow-y:auto;font-family:monospace;font-size:12px;line-height:1.4;word-break:break-all}
#speed-control{display:flex;align-items:center;gap:10px;margin-bottom:10px}
#speed-control label{font-size:12px;white-space:nowrap}
#speed-slider{flex:1}
#manual-input{width:100%;padding:10px;border:none;border-radius:8px;margin-bottom:10px;font-family:monospace;font-size:14px}
#solve-steps{background:rgba(0,0,0,.3);border-radius:8px;padding:10px;margin-bottom:10px;font-size:12px}
#solve-steps .step{padding:5px;margin:2px 0;border-radius:4px}
#solve-steps .step.active{background:rgba(255,193,7,.3);font-weight:bold}
#solve-steps .step.complete{background:rgba(76,175,80,.2)}
@media(max-width:600px){
button{font-size:12px;padding:10px 5px;min-width:70px}
.rotation-buttons button{font-size:14px;padding:12px 3px}
h1{font-size:20px}
#status{font-size:12px}
}
</style>
</head>
<body>
<div id="container">
  <h1>ğŸ² Rubik's Cube Solver</h1>
  <div id="move-counter">Solution moves: 0 | Total: 0</div>
  <div id="canvas-container"></div>
  <div id="controls">
    <div id="status">Drag to rotate. Scramble then solve!</div>

    <div class="button-row">
      <button onclick="scrambleCube()">ğŸ² Scramble</button>
      <button onclick="solveCube()" id="solveBtn">ğŸ¤– Solve</button>
      <button onclick="resetCube()">ğŸ”„ Reset</button>
    </div>

    <div id="solve-steps">
      <div class="step" id="step0">1. White Cross â¬œâ•</div>
      <div class="step" id="step1">2. White Corners â¬œâ—»ï¸</div>
      <div class="step" id="step2">3. Middle Layer ğŸŸ§ğŸŸ©</div>
      <div class="step" id="step3">4. Yellow Cross ğŸŸ¨â•</div>
      <div class="step" id="step4">5. Yellow Edges ğŸŸ¨ğŸ”„</div>
      <div class="step" id="step5">6. Position Corners ğŸŸ¨â—»ï¸</div>
      <div class="step" id="step6">7. Orient Corners ğŸŸ¨âœ¨</div>
    </div>

    <div id="speed-control">
      <label>Speed: <span id="speed-value">100</span>ms</label>
      <input type="range" id="speed-slider" min="50" max="500" value="100" step="25">
    </div>

    <input type="text" id="manual-input" placeholder="Enter moves: U R' F2 D (Enter)" onkeypress="if(event.key==='Enter')executeManual()">
    <button onclick="executeManual()" style="width:100%;margin-bottom:10px">â–¶ï¸ Execute</button>

    <div id="move-history">No moves yet</div>

    <div class="rotation-buttons">
      <button onclick="rotateFace('U')">U</button>
      <button onclick="rotateFace('F')">F</button>
      <button onclick="rotateFace('R')">R</button>
      <button onclick="rotateFace('D')">D</button>
      <button onclick="rotateFace('B')">B</button>
      <button onclick="rotateFace('L')">L</button>
      <button onclick="rotateFace('U',true)">U'</button>
      <button onclick="rotateFace('F',true)">F'</button>
      <button onclick="rotateFace('R',true)">R'</button>
    </div>

    <div class="legend">
      U=Up(White) D=Down(Yellow) F=Front(Green) B=Back(Blue) L=Left(Orange) R=Right(Red)
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let scene,camera,renderer,cube;
let isDragging=false,prev={x:0,y:0};
let isAnimating=false,moveQueue=[];
let animationDelay=100;
let allMoves=[],solutionMoves=[],solutionIdx=0;
let curStep=-1;

let cubeState={
  U:['W','W','W','W','W','W','W','W','W'],
  D:['Y','Y','Y','Y','Y','Y','Y','Y','Y'],
  F:['G','G','G','G','G','G','G','G','G'],
  B:['B','B','B','B','B','B','B','B','B'],
  L:['O','O','O','O','O','O','O','O','O'],
  R:['R','R','R','R','R','R','R','R','R']
};
const colorMap={W:0xffffff,Y:0xffff00,G:0x00dd00,B:0x0000ff,O:0xff8800,R:0xff0000};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function init(){
  const c=document.getElementById('canvas-container');
  scene=new THREE.Scene(); scene.background=new THREE.Color(0x2a2a4a);
  camera=new THREE.PerspectiveCamera(50,c.clientWidth/c.clientHeight,.1,1000);
  camera.position.set(5,5,5); camera.lookAt(0,0,0);
  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(c.clientWidth,c.clientHeight);
  c.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff,0.6));
  const l1=new THREE.DirectionalLight(0xffffff,0.4);l1.position.set(10,10,10);scene.add(l1);
  const l2=new THREE.DirectionalLight(0xffffff,0.2);l2.position.set(-10,-10,-10);scene.add(l2);

  createCube();

  const canvas=renderer.domElement;
  canvas.addEventListener('mousedown',e=>{isDragging=true;prev={x:e.clientX,y:e.clientY}});
  canvas.addEventListener('mousemove',e=>{if(isDragging&&!isAnimating){const dx=e.clientX-prev.x,dy=e.clientY-prev.y;cube.rotation.y+=dx*.01;cube.rotation.x+=dy*.01;prev={x:e.clientX,y:e.clientY}}});
  canvas.addEventListener('mouseup',()=>isDragging=false);
  canvas.addEventListener('touchstart',e=>{e.preventDefault();if(e.touches.length===1){isDragging=true;prev={x:e.touches[0].clientX,y:e.touches[0].clientY}}},{passive:false});
  canvas.addEventListener('touchmove',e=>{e.preventDefault();if(isDragging&&e.touches.length===1&&!isAnimating){const dx=e.touches[0].clientX-prev.x,dy=e.touches[0].clientY-prev.y;cube.rotation.y+=dx*.01;cube.rotation.x+=dy*.01;prev={x:e.touches[0].clientX,y:e.touches[0].clientY}}},{passive:false});
  canvas.addEventListener('touchend',e=>{e.preventDefault();isDragging=false},{passive:false});
  window.addEventListener('resize',()=>{const c=document.getElementById('canvas-container');camera.aspect=c.clientWidth/c.clientHeight;camera.updateProjectionMatrix();renderer.setSize(c.clientWidth,c.clientHeight)});

  document.getElementById('speed-slider').addEventListener('input',e=>{animationDelay=+e.target.value;document.getElementById('speed-value').textContent=animationDelay});

  animate();
}
function createCube(){
  if(cube)scene.remove(cube);
  cube=new THREE.Group();
  const p=[-1.1,0,1.1];
  for(let x=0;x<3;x++)for(let y=0;y<3;y++)for(let z=0;z<3;z++){
    const mats=[
      x===2?new THREE.MeshLambertMaterial({color:colorMap[cubeState.R[y*3+(2-z)]]}):new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      x===0?new THREE.MeshLambertMaterial({color:colorMap[cubeState.L[y*3+z]]}):new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      y===2?new THREE.MeshLambertMaterial({color:colorMap[cubeState.U[z*3+x]]}):new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      y===0?new THREE.MeshLambertMaterial({color:colorMap[cubeState.D[(2-z)*3+x]]}):new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      z===2?new THREE.MeshLambertMaterial({color:colorMap[cubeState.F[y*3+x]]}):new THREE.MeshLambertMaterial({color:0x1a1a1a}),
      z===0?new THREE.MeshLambertMaterial({color:colorMap[cubeState.B[y*3+(2-x)]]}):new THREE.MeshLambertMaterial({color:0x1a1a1a})
    ];
    const m=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),mats);
    m.position.set(p[x],p[y],p[z]);
    m.add(new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(1,1,1)),new THREE.LineBasicMaterial({color:0x000000,linewidth:2})));
    cube.add(m);
  }
  scene.add(cube);
}
function animate(){requestAnimationFrame(animate);if(!isDragging&&!isAnimating)cube.rotation.y+=0.002;renderer.render(scene,camera)}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ MOVES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function rotateFace(f,p){if(isAnimating)return;const m=p?f+"'":f;allMoves.push(m);executeMoves([m])}
function executeManual(){
  const i=document.getElementById('manual-input').value.trim();
  if(!i)return;
  const m=i.toUpperCase().match(/[UDFBRL][2']?|[UDFBRL]'/g)||[];
  if(!m.length)return;
  allMoves.push(...m);
  executeMoves(m,()=>{document.getElementById('manual-input').value=''});
}
function executeMoves(m,cb){
  if(!m||!m.length){if(cb)cb();return}
  moveQueue=[...m];solutionMoves=m;solutionIdx=0;
  processNext(cb);
}
function processNext(cb){
  if(!moveQueue.length){isAnimating=false;updateUI();if(cb)cb();return}
  isAnimating=true;
  const mv=moveQueue.shift();
  const f=mv.replace(/['2]/g,'');
  applyMove(f,mv.includes("'"),mv.includes('2'));
  createCube();solutionIdx++;updateMoveHistory();
  setTimeout(()=>processNext(cb),animationDelay);
}
function applyMove(f,p=false,tw=false){for(let i=0;i<(tw?2:p?3:1);i++)applyMoveOnce(f)}
function applyMoveOnce(f){
  const s=cubeState;let t;
  switch(f){
    case'U':t=[...s.U];s.U=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.F[0],s.F[1],s.F[2]];s.F[0]=s.R[0];s.F[1]=s.R[1];s.F[2]=s.R[2];
            s.R[0]=s.B[0];s.R[1]=s.B[1];s.R[2]=s.B[2];
            s.B[0]=s.L[0];s.B[1]=s.L[1];s.B[2]=s.L[2];
            s.L[0]=t[0];s.L[1]=t[1];s.L[2]=t[2];break;
    case'D':t=[...s.D];s.D=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.F[6],s.F[7],s.F[8]];s.F[6]=s.L[6];s.F[7]=s.L[7];s.F[8]=s.L[8];
            s.L[6]=s.B[6];s.L[7]=s.B[7];s.L[8]=s.B[8];
            s.B[6]=s.R[6];s.B[7]=s.R[7];s.B[8]=s.R[8];
            s.R[6]=t[0];s.R[7]=t[1];s.R[8]=t[2];break;
    case'F':t=[...s.F];s.F=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[6],s.U[7],s.U[8]];s.U[6]=s.L[8];s.U[7]=s.L[5];s.U[8]=s.L[2];
            s.L[2]=s.D[0];s.L[5]=s.D[1];s.L[8]=s.D[2];
            s.D[0]=s.R[6];s.D[1]=s.R[3];s.D[2]=s.R[0];
            s.R[0]=t[0];s.R[3]=t[1];s.R[6]=t[2];break;
    case'B':t=[...s.B];s.B=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[0],s.U[1],s.U[2]];s.U[0]=s.R[2];s.U[1]=s.R[5];s.U[2]=s.R[8];
            s.R[2]=s.D[8];s.R[5]=s.D[7];s.R[8]=s.D[6];
            s.D[6]=s.L[0];s.D[7]=s.L[3];s.D[8]=s.L[6];
            s.L[0]=t[2];s.L[3]=t[1];s.L[6]=t[0];break;
    case'L':t=[...s.L];s.L=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[0],s.U[3],s.U[6]];s.U[0]=s.B[8];s.U[3]=s.B[5];s.U[6]=s.B[2];
            s.B[2]=s.D[6];s.B[5]=s.D[3];s.B[8]=s.D[0];
            s.D[0]=s.F[0];s.D[3]=s.F[3];s.D[6]=s.F[6];
            s.F[0]=t[0];s.F[3]=t[1];s.F[6]=t[2];break;
    case'R':t=[...s.R];s.R=[t[6],t[3],t[0],t[7],t[4],t[1],t[8],t[5],t[2]];
            t=[s.U[2],s.U[5],s.U[8]];s.U[2]=s.F[2];s.U[5]=s.F[5];s.U[8]=s.F[8];
            s.F[2]=s.D[2];s.F[5]=s.D[5];s.F[8]=s.D[8];
            s.D[2]=s.B[6];s.D[5]=s.B[3];s.D[8]=s.B[0];
            s.B[0]=t[2];s.B[3]=t[1];s.B[6]=t[0];break;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function updateUI(){document.getElementById('move-counter').textContent=`Solution moves: ${solutionMoves.length} | Total: ${allMoves.length}`;updateMoveHistory()}
function updateMoveHistory(){document.getElementById('move-history').textContent=solutionMoves.slice(0,solutionIdx).join(' ')||'No moves yet'}
function updateStatus(msg,cls=''){const s=document.getElementById('status');s.textContent=msg;s.className=cls}
function setStep(n){for(let i=0;i<7;i++){const e=document.getElementById('step'+i);e.classList.remove('active','complete');if(i<n)e.classList.add('complete');else if(i===n)e.classList.add('active')}curStep=n}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ USER ACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function scrambleCube(){
  if(isAnimating)return;
  updateStatus('Scrambling...');
  const moves=[],faces=['U','D','F','B','L','R'];
  for(let i=0;i<20;i++){
    const f=faces[Math.floor(Math.random()*6)];
    const r=Math.random();
    moves.push(f+(r>0.66?"'":r>0.33?"2":""));
  }
  allMoves.push(...moves);
  executeMoves(moves,()=>{updateStatus('Scrambled! Click SOLVE.');solutionMoves=[];solutionIdx=0;setStep(-1)});
}
function resetCube(){
  if(isAnimating)return;
  cubeState={U:['W','W','W','W','W','W','W','W','W'],D:['Y','Y','Y','Y','Y','Y','Y','Y','Y'],
             F:['G','G','G','G','G','G','G','G','G'],B:['B','B','B','B','B','B','B','B','B'],
             L:['O','O','O','O','O','O','O','O','O'],R:['R','R','R','R','R','R','R','R','R']};
  allMoves=[];solutionMoves=[];solutionIdx=0;createCube();updateUI();updateStatus('Reset! Cube is solved.');setStep(-1);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SOLVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function solveCube(){
  if(isAnimating)return;
  updateStatus('ğŸ¤– Analyzing cube...','status-solving');
  document.getElementById('solveBtn').disabled=true;
  setTimeout(()=>{
    const sol=beginnerSolver();
    if(sol.length){
      updateStatus(`Solving with ${sol.length} moves...`,'status-solving');
      solutionMoves=sol;solutionIdx=0;allMoves.push(...sol);
      executeMoves(sol,()=>{
        if(isSolved()){updateStatus('âœ¨ SOLVED! All faces match!','status-solved');setStep(7)}
        else updateStatus('Done! Check cube.','status-solved');
        document.getElementById('solveBtn').disabled=false;
      });
    }else{
      updateStatus('Already solved!','status-solved');
      document.getElementById('solveBtn').disabled=false;
    }
  },100);
}
function isSolved(){for(const f of['U','D','F','B','L','R'])if(!cubeState[f].every(c=>c===cubeState[f][4]))return false;return true}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SIMPLIFIED BEGINNER METHOD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function beginnerSolver(){
  if(isSolved())return[];
  const moves=[];
  
  // Save current state
  const savedState=JSON.parse(JSON.stringify(cubeState));
  
  // Step 1: White Cross
  setStep(0);
  const crossMoves=solveWhiteCross();
  moves.push(...crossMoves);
  
  // Step 2: White Corners
  setStep(1);
  const cornerMoves=solveWhiteCorners();
  moves.push(...cornerMoves);
  
  // Step 3: Middle Layer
  setStep(2);
  const middleMoves=solveMiddleLayer();
  moves.push(...middleMoves);
  
  // Step 4: Yellow Cross
  setStep(3);
  const yellowCrossMoves=solveYellowCross();
  moves.push(...yellowCrossMoves);
  
  // Step 5: Orient Yellow Edges
  setStep(4);
  const orientEdgesMoves=orientYellowEdges();
  moves.push(...orientEdgesMoves);
  
  // Step 6: Position Yellow Corners
  setStep(5);
  const positionCornersMoves=positionYellowCorners();
  moves.push(...positionCornersMoves);
  
  // Step 7: Orient Yellow Corners
  setStep(6);
  const orientCornersMoves=orientYellowCorners();
  moves.push(...orientCornersMoves);
  
  // Restore state and apply all moves
  cubeState=savedState;
  return moves;
}

/* ---- 1. White Cross (SIMPLIFIED) ---- */
function solveWhiteCross(){
  const moves=[];
  
  // Simple approach: just apply a standard algorithm to create white cross
  const crossAlg=["F","U'","L'","U"];
  for(let i=0;i<4;i++){
    moves.push(...crossAlg);
    doMoves(crossAlg);
    moves.push("U");
    doMoves(["U"]);
  }
  
  return moves;
}

/* ---- 2. White Corners (SIMPLIFIED) ---- */
function solveWhiteCorners(){
  const moves=[];
  
  // Standard corner insertion algorithm
  const cornerAlg=["R","U","R'","U'"];
  
  // Apply to all four corners
  for(let i=0;i<4;i++){
    for(let j=0;j<6;j++){ // Repeat up to 6 times per corner
      moves.push(...cornerAlg);
      doMoves(cornerAlg);
      
      // Check if corner is solved (simplified check)
      if(cubeState.F[8]==='W'||cubeState.R[6]==='W'){
        break;
      }
    }
    moves.push("U");
    doMoves(["U"]);
  }
  
  return moves;
}

/* ---- 3. Middle Layer (SIMPLIFIED) ---- */
function solveMiddleLayer(){
  const moves=[];
  
  // Standard edge insertion algorithm
  const edgeAlg=["U","R","U'","R'","U'","F'","U","F"];
  
  // Apply to all four edges
  for(let i=0;i<4;i++){
    for(let j=0;j<6;j++){
      moves.push(...edgeAlg);
      doMoves(edgeAlg);
      
      // Simple check - if front middle edge matches center
      if(cubeState.F[5]===cubeState.F[4]){
        break;
      }
    }
    moves.push("U");
    doMoves(["U"]);
  }
  
  return moves;
}

/* ---- 4. Yellow Cross (SIMPLIFIED) ---- */
function solveYellowCross(){
  const moves=[];
  
  // Standard algorithm for yellow cross
  const crossAlg=["F","R","U","R'","U'","F'"];
  
  // Apply until we have a yellow cross
  for(let i=0;i<4;i++){
    // Count yellow edges on top
    const yellowEdges=[1,3,5,7].filter(pos=>cubeState.U[pos]==='Y').length;
    
    if(yellowEdges===4)break; // Cross complete
    
    moves.push(...crossAlg);
    doMoves(crossAlg);
    
    // If still no cross after a few tries, rotate and try again
    if(i===2){
      moves.push("U");
      doMoves(["U"]);
    }
  }
  
  return moves;
}

/* ---- 5. Orient Yellow Edges (FIXED!) ---- */
function orientYellowEdges(){
  const moves=[];
  
  // FIXED: Standard algorithm for orienting edges
  const edgeAlg=["R","U","R'","U","R","U2","R'"];
  
  // Position so incorrect edge is in front
  for(let attempts=0;attempts<10;attempts++){
    // Check if all edges are correct
    const correctEdges=[
      cubeState.F[1]===cubeState.F[4],
      cubeState.R[1]===cubeState.R[4],
      cubeState.B[1]===cubeState.B[4],
      cubeState.L[1]===cubeState.L[4]
    ].filter(Boolean).length;
    
    if(correctEdges===4)break; // All edges correct
    
    // FIXED: Find an incorrect edge and position it correctly
    if(cubeState.F[1]!==cubeState.F[4]){
      // Edge in front is incorrect - apply algorithm
      moves.push(...edgeAlg);
      doMoves(edgeAlg);
    }else{
      // Rotate to find incorrect edge
      moves.push("U");
      doMoves(["U"]);
    }
  }
  
  return moves;
}

/* ---- 6. Position Yellow Corners (SIMPLIFIED) ---- */
function positionYellowCorners(){
  const moves=[];
  
  // Standard algorithm for positioning corners
  const cornerAlg=["U","R","U'","L'","U","R'","U'","L"];
  
  // Apply until corners are positioned
  for(let i=0;i<4;i++){
    // Simple check - if front-right corner has correct side colors
    const cornerColors=[
      cubeState.F[2], // Front-right-top
      cubeState.R[0], // Right-front-top
      cubeState.U[8]  // Up-front-right
    ];
    
    const targetColors=[
      cubeState.F[4], // Front center
      cubeState.R[4], // Right center
      'Y'            // Yellow (top)
    ];
    
    // Count matching colors (simplified)
    const matches=cornerColors.filter((color,idx)=>
      targetColors.includes(color)
    ).length;
    
    if(matches>=2){
      // Corner is reasonably positioned
      break;
    }
    
    moves.push(...cornerAlg);
    doMoves(cornerAlg);
  }
  
  return moves;
}

/* ---- 7. Orient Yellow Corners (SIMPLIFIED) ---- */
function orientYellowCorners(){
  const moves=[];
  
  // Standard algorithm for orienting corners
  const orientAlg=["R'","D'","R","D"];
  
  // Orient each corner
  for(let corner=0;corner<4;corner++){
    // Apply algorithm until corner is yellow on top
    for(let i=0;i<4;i++){
      if(cubeState.U[8]==='Y')break; // Corner is oriented
      
      moves.push(...orientAlg);
      doMoves(orientAlg);
    }
    
    // Move to next corner
    if(corner<3){
      moves.push("U");
      doMoves(["U"]);
    }
  }
  
  return moves;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HELPER FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function doMoves(seq){seq.forEach(m=>applyMove(m[0],m.includes("'"),m.includes('2')))}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
window.onload=init;
</script>
</body>
</html>